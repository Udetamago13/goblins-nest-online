<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ゴブリンの巣穴 Online Ver.Beta 2.7</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'DotGothic16', sans-serif;
            display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh;
            color: white;
        }
        #game-wrapper { position: relative; }
        #game-container { position: relative; width: 1024px; height: 576px; background: #111; overflow: hidden; box-shadow: 0 0 20px #333; }
        
        /* 入場ゲート画面 */
        #gate-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .gate-input {
            background: #000; border: 1px solid #555; color: #fff;
            font-family: 'DotGothic16', sans-serif; font-size: 24px;
            text-align: center; width: 200px; padding: 5px; margin-bottom: 20px;
            outline: none;
        }
        .gate-btn {
            background: #222; border: 1px solid #fff; color: #fff;
            font-family: 'DotGothic16', sans-serif; font-size: 20px;
            padding: 5px 20px; cursor: pointer;
        }
        .gate-btn:hover { background: #444; }

        @keyframes greyTrip {
            0% { filter: brightness(var(--bright)) saturate(1.2) hue-rotate(-15deg) contrast(1.1); }
            50% { filter: brightness(var(--bright)) saturate(1.2) hue-rotate(15deg) contrast(1.1); }
            100% { filter: brightness(var(--bright)) saturate(1.2) hue-rotate(-15deg) contrast(1.1); }
        }
        .grey-mode-canvas {
            animation: greyTrip 5s infinite ease-in-out;
        }
        
        canvas { 
            display: block;
            image-rendering: pixelated; 
            --bright: 1.0; 
        }
        .game-input-area {
            position: absolute; background: transparent; border: none; outline: none;
            color: white; font-family: 'DotGothic16', sans-serif; text-align: center;
            display: none; padding: 0; margin: 0; resize: none; overflow: hidden; line-height: 1.2;
            z-index: 10;
        }
        .game-input-area:disabled, .game-input-line:disabled {
            color: #888; cursor: not-allowed;
        }
        .game-input-line {
            position: absolute; background: transparent; border: none; outline: none;
            color: white; font-family: 'DotGothic16', sans-serif; text-align: center; display: none;
            z-index: 10;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: none;
        }
        #info-panel { 
            position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 14px; 
            padding: 10px; background: rgba(0,0,0,0.7); border-radius: 8px; line-height: 1.6; 
            display: none; white-space: pre-wrap;
        }
        #signal-message {
            position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0; font-size: 28px; text-shadow: 1px 1px 0 #000;
            opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 30;
            background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 15px; 
            border: 2px solid rgba(255,255,255,0.5);
            letter-spacing: 2px; text-align: center; white-space: pre-wrap;
        }
        #result-rank {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 28px; background: rgba(0,0,0,0.9); padding: 40px 60px;
            border-radius: 30px; display: none; text-align: center; line-height: 1.8;
            width: 80%; box-shadow: 0 0 30px #0ff; pointer-events: auto; z-index: 20;
        }
        #controls-help {
            margin-top: 10px; color: #aaa; font-size: 14px; text-align: center; width: 1024px;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="game-container">
        <div id="gate-screen">
            <input type="text" id="gate-pass" class="gate-input" maxlength="10">
            <button id="gate-btn" class="gate-btn">決定</button>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        <textarea id="nameInput" class="game-input-area" maxlength="100"></textarea>
        <input type="text" id="passInput" class="game-input-line" maxlength="6">

        <div id="ui-layer">
            <div id="info-panel"></div>
            <div id="signal-message"></div>
            <div id="result-rank">
                <div id="guild-comment"></div>
                <div id="rank-grade" style="font-size: 60px; color: #ff0; margin: 10px 0;"></div>
                <div id="rank-time" style="font-size:20px; margin:20px 0;"></div>
                <div id="restart-hint" style="font-size:16px; color:#aaa; margin-top:20px;"></div>
            </div>
        </div>
    </div>
    <div id="controls-help"></div>
</div>

<script>
// --- Xorshift乱数生成クラス ---
class Xorshift {
    constructor(seed = 88675123) {
        this.x = 123456789;
        this.y = 362436069;
        this.z = 521288629;
        this.w = seed;
    }
    nextFloat() {
        let t = this.x ^ (this.x << 11);
        this.x = this.y; this.y = this.z; this.z = this.w;
        this.w = (this.w ^ (this.w >>> 19)) ^ (t ^ (t >>> 8));
        return (this.w >>> 0) / 4294967296;
    }
} // --- Xorshift 終了 ---

// --- 音響資源管理用シングルトン ---
let sharedAudioCtx = null;

function getSharedAudioContext() {
    if (!sharedAudioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) sharedAudioCtx = new AC();
    }
    if (sharedAudioCtx && sharedAudioCtx.state === 'suspended') {
        sharedAudioCtx.resume().catch(()=>{});
    }
    return sharedAudioCtx;
} // --- getSharedAudioContext 終了 ---

function hashCode(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; 
    }
    return Math.abs(hash) + 1;
} // --- hashCode 終了 ---

function safeGetItem(key) {
    try {
        return localStorage.getItem(key);
    } catch (e) {
        console.warn('Storage access blocked:', e);
        return null;
    }
} 

function safeSetItem(key, val) {
    try {
        localStorage.setItem(key, val);
    } catch (e) {
        console.warn('Storage saving blocked:', e);
    }
} 

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nameEl = document.getElementById('nameInput');
const passEl = document.getElementById('passInput');
const uiLayer = document.getElementById('ui-layer');
const infoPanel = document.getElementById('info-panel');
const signalMsgEl = document.getElementById('signal-message');
const controlsHelpEl = document.getElementById('controls-help');

const gateScreen = document.getElementById('gate-screen');
const gatePassInput = document.getElementById('gate-pass');
const gateBtn = document.getElementById('gate-btn');

let rnd = new Xorshift(); 

let savedBgm = safeGetItem('goblinsNest_bgmVol');
let bgmVolume = savedBgm !== null ? parseFloat(savedBgm) : 0.5;
let savedSe = safeGetItem('goblinsNest_seVol');
let seVolume = savedSe !== null ? parseFloat(savedSe) : 0.5;
let savedBright = safeGetItem('goblinsNest_bright');
let brightnessLevel = savedBright !== null ? parseFloat(savedBright) : 0.5;

if (canvas) {
    const bVal = 0.6 + (brightnessLevel * 0.8);
    canvas.style.setProperty('--bright', bVal.toFixed(2));
    canvas.style.filter = `brightness(${bVal.toFixed(2)})`;
}

let isMutedBGM = safeGetItem('goblinsNest_muteBGM') === 'true';
let isMutedSE = safeGetItem('goblinsNest_muteSE') === 'true';

nameEl.value = safeGetItem('goblinsNest_name') || "";
passEl.value = safeGetItem('goblinsNest_pass') || "";

const VIRTUAL_WIDTH = 1024;
const VIRTUAL_HEIGHT = 576;
canvas.width = VIRTUAL_WIDTH;
canvas.height = VIRTUAL_HEIGHT;

let gameState = 'gate'; 
let isInputLocked = false; 
let isDraggingBGM = false;
let isDraggingSE = false;
let isDraggingBright = false; 

const PEER_ID_PREFIX = 'gn_beta2_'; 
let peer = null;
let conn = null;
let isMatching = false; 
let isConnected = false; 
let isHost = false; 
let guestInputState = { dx: 0, dy: 0, attack: false }; 
let lastSyncTime = 0;
const SYNC_INTERVAL = 33; 

let otherPlayerName = ""; 

let isGreyMode = false;
let isDebugMode = false; 
let psychicArrays = []; 
let currentBgmDebugName = ""; 

const BAR_W = 80, BAR_H = 15;
const UI_X = VIRTUAL_WIDTH - (BAR_W + 20), UI_Y_START = 30;

const titleBgImg = new Image(); titleBgImg.src = 'assets/bg/title_bg.png';
const titleBGM = new Audio('assets/bgm/title_bgm.mp3'); titleBGM.loop = true;
const clearBGM = new Audio('assets/bgm/clear.mp3'); clearBGM.loop = true; 

const TILE_SIZE = 8;
const ZOOM = 7;
const SCALED_TILE = TILE_SIZE * ZOOM; 
const VIEW_TILES_X = 18;
const VIEW_TILES_Y = 10; 
const DARKNESS_WIDTH = VIEW_TILES_X * SCALED_TILE; 
const DARKNESS_HEIGHT = VIEW_TILES_Y * SCALED_TILE; 
const GAME_OFFSET_X = (VIRTUAL_WIDTH - DARKNESS_WIDTH) / 2; 
const GAME_OFFSET_Y = (VIRTUAL_HEIGHT - DARKNESS_HEIGHT) / 2; 

const GRID_W = 100;
const GRID_H = 100;
const DIRS = [[0,-1],[1,0],[0,1],[-1,0]]; 
const VISION_RADIUS = 3; 
const IDLE_COOLDOWN = 2000;
const CHASE_COOLDOWN = 1000;
const GOBLIN_ATTACK_INTERVAL = 650;
const GREY_ARRAY_COOLDOWN = 3000; 
const RAGE_COOLDOWN = 180;
const GOBLIN_LOOK_INTERVAL = 300;
const GOBLIN_UPDATE_INTERVAL = 80;
const MINIMAP_UPDATE_INTERVAL = 200;
const ATTACK_SHAKE = 2;
const HIT_SHAKE_DURATION = 120;
const HIT_SHAKE_POWER = 3;
const ATTACK_SCALE_START = 1.3;
const IFRAME_DURATION = 500;
const SMELL_RADIUS = 3;
const SIGHT_RADIUS = 7;
const DAUGHTER_OFFSET_Y = 0.3;
const ATTACK_COOLDOWN = 0.1;

const STATE = { IDLE: 'idle', ALERT: 'alert', LOCK: 'lock', RAGE: 'rage', CHARGE: 'charge', REAPPEAR: 'reappear', DYING: 'dying' };

const visionRadius = (VISION_RADIUS + 0.5) * SCALED_TILE;
const visionSize = visionRadius * 2;

const visionHoleCanvas = document.createElement('canvas');
visionHoleCanvas.width = visionSize; visionHoleCanvas.height = visionSize;
const vhCtx = visionHoleCanvas.getContext('2d');
const vhGrad = vhCtx.createRadialGradient(visionRadius, visionRadius, 0, visionRadius, visionRadius, visionRadius);
vhGrad.addColorStop(0, "rgba(0,0,0,1)");             
vhGrad.addColorStop(0.5, "rgba(0,0,0,1)");        
vhGrad.addColorStop(1, "rgba(0,0,0,0)");             
vhCtx.fillStyle = vhGrad;
vhCtx.beginPath(); vhCtx.arc(visionRadius, visionRadius, visionRadius, 0, Math.PI*2); vhCtx.fill();

const dreamyGlowCanvas = document.createElement('canvas');
dreamyGlowCanvas.width = visionSize; dreamyGlowCanvas.height = visionSize;
const dgCtx = dreamyGlowCanvas.getContext('2d');
const dgGrad = dgCtx.createRadialGradient(visionRadius, visionRadius, 0, visionRadius, visionRadius, visionRadius);
dgGrad.addColorStop(0, "rgba(0, 255, 100, 0.2)");
dgGrad.addColorStop(0.3, "rgba(0, 255, 100, 0.1)");
dgGrad.addColorStop(0.8, "rgba(0, 0, 0, 0)");
dgCtx.fillStyle = dgGrad;
dgCtx.beginPath(); dgCtx.arc(visionRadius, visionRadius, visionRadius, 0, Math.PI*2); dgCtx.fill();

const FLOOR_COLORS_56 = [];
for(let i=0; i<50; i++) {
    const hue = (i * 137.5) % 360; 
    const sat = 70 + (i % 4) * 10; 
    const light = 50 + (i % 3) * 10; 
    FLOOR_COLORS_56.push(`hsl(${hue}, ${sat}%, ${light}%)`);
}
FLOOR_COLORS_56.push("#e0e0e0"); 
FLOOR_COLORS_56.push("#2a2a2a"); 
FLOOR_COLORS_56.push("#c5b358"); 
FLOOR_COLORS_56.push("#c0c0c0"); 
FLOOR_COLORS_56.push("#cd7f32"); 
FLOOR_COLORS_56.push("#e5e4e2"); 

const NORMAL_BGMS_56 = [];
const RAGE_BGMS_56 = [];
for(let i=0; i<56; i++) {
    NORMAL_BGMS_56.push("assets/bgm/normal_" + (i+1) + ".mp3");
    RAGE_BGMS_56.push("assets/bgm/rage_" + (i+1) + ".mp3");
}

let deckColorIndices = [];
let deckNormalIndices = [];
let deckRageIndices = [];
let currentDeckIndex = 0;
let playCount = 0;

const S_KEY_PREFIX_DEBUG = 'gn_debug_';
const S_KEY_PREFIX_REAL = 'gn_real_';

let currentStageColor = null;
let currentStageBgm = { normal: null, rage: null };
let debugCurrentNormalIdx = -1;
let debugCurrentRageIdx = -1;

let currentAudio = null;
let fadeInterval = null; 
let currentMusicState = 'normal';

const floorTileImg = new Image(); floorTileImg.src = 'assets/floor/floor_tile.png';
const goblinImages = { front: new Image(), back: new Image(), side: new Image() };
goblinImages.front.src = 'assets/goblin/goblin_front.png';
goblinImages.back.src = 'assets/goblin/goblin_back.png';
goblinImages.side.src = 'assets/goblin/goblin_side.png'; 
const goblinAttackImg = new Image(); goblinAttackImg.src = 'assets/goblin/goblin_attack.png';

const greyImg = new Image(); greyImg.src = 'assets/enemies/grey.png';
const greySpaceFloorImg = new Image(); greySpaceFloorImg.src = 'assets/tiles/grey_space.png';
const greyCircleImg = new Image(); greyCircleImg.src = 'assets/effects/grey_circle.png';
const greyBGM = new Audio('assets/bgm/bgm_grey.mp3'); greyBGM.loop = true;

const playerImages = { front: new Image(), back: new Image(), right1: new Image(), right2: new Image() };
playerImages.front.src = 'assets/player/player1_front.png';
playerImages.back.src = 'assets/player/player1_back.png';
playerImages.right1.src = 'assets/player/player1_right1.png';
playerImages.right2.src = 'assets/player/player1_right2.png';
const playerAttackImg = new Image(); playerAttackImg.src = 'assets/player/player_attack.png';

const daughterImg = new Image(); daughterImg.src = 'assets/daughter/daughter.png';
const biscuitImg = new Image(); biscuitImg.src = 'assets/items/biscuit.png';

const SE = {
    goblinAttack: [new Audio('assets/se/goblin_attack1.wav'), new Audio('assets/se/goblin_attack2.wav')],
    goblinHit: [new Audio('assets/se/goblin_hit1.wav'), new Audio('assets/se/goblin_hit2.wav')],
    playerAttack1: new Audio('assets/se/player_attack1.wav'),
    playerAttack2: new Audio('assets/se/player_attack2.wav'),
    playerHit1: new Audio('assets/se/player_hit1.wav'),
    playerHit2: new Audio('assets/se/player_hit2.wav')
};
Object.values(SE).flat().forEach(audio => { audio.preload = 'auto'; });

let grid = [], floorVariant = [];
let player1 = {x: 0, y: 0, facing: 1, hitShakeTime: 0, stepCount: 0, deathDir: 0};
let player2 = {x: 0, y: 0, facing: 1, hitShakeTime: 0, stepCount: 0, deathDir: 0};
let daughter = {x: 0, y: 0, rescued: false, rescuer: null};
let healingBiscuit = {x: -1, y: -1, active: false};
let goblins = [];
let rooms = [];
let attackEffects = [];
let hpP1 = 10, hpP2 = 10;
let lastAttackTimeP1 = 0, lastAttackTimeP2 = 0;
let p1LastHitTime = 0, p2LastHitTime = 0;
let startTime = 0, fixedTime = 0;
let timerStopped = false, foundDaughter = false, foundDaughterNotified = false, gameCleared = false, isGameOver = false;
let distanceToDaughter = 0;
let shortestPathSteps = 0; 
let startLeftX = 0, startRightX = 0, startBottomY = 0;

let floorCanvas = document.createElement('canvas');
let floorCtx = floorCanvas.getContext('2d');
let floorDrawn = false;
let darknessCanvas = document.createElement('canvas');
let darknessCtx = darknessCanvas.getContext('2d');
darknessCanvas.width = DARKNESS_WIDTH; darknessCanvas.height = DARKNESS_HEIGHT;
let minimapCanvas = document.createElement('canvas');
let minimapCtx = minimapCanvas.getContext('2d');
let minimapFloorCanvas = document.createElement('canvas');
let minimapFloorCtx = minimapFloorCanvas.getContext('2d');
let minimapFloorDrawn = false;
let lastMinimapUpdate = 0;

let signalState = { 
    active: false, 
    type: null, 
    p1: false,  
    p2: false,  
    startTime: 0,
    agreedTime: 0 
};

if (safeGetItem('goblinsNest_gatePassed')) {
    gateScreen.style.display = 'none';
    gameState = 'title';
}

gatePassInput.addEventListener('input', () => {
    gatePassInput.value = gatePassInput.value.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
});

function attemptGatePass() {
    if (gatePassInput.value && gatePassInput.value.trim().toLowerCase() === 'cave') {
        playClickSound(); 
        gateScreen.style.display = 'none';
        gameState = 'title';
        safeSetItem('goblinsNest_gatePassed', 'true');
        isInputLocked = true;
        setTimeout(() => { isInputLocked = false; }, 500);
    } else {
        gatePassInput.value = '';
        gateScreen.style.backgroundColor = '#200';
        setTimeout(() => gateScreen.style.backgroundColor = '#000', 100);
    }
} 

gateBtn.addEventListener('click', attemptGatePass);

gatePassInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.isComposing) {
        attemptGatePass();
    }
});

function updateBrightnessFilter() {
    const bVal = 0.6 + (brightnessLevel * 0.8);
    canvas.style.setProperty('--bright', bVal.toFixed(2));
    if (!isGreyMode) {
        canvas.style.filter = `brightness(${bVal.toFixed(2)})`;
    } else {
        canvas.style.filter = ""; 
    }
} 

function update() {
    if (gameState === 'gate') {
        requestAnimationFrame(update);
        return;
    }

    const realBGMVol = isMutedBGM ? 0 : bgmVolume;
    const realSEVol = isMutedSE ? 0 : seVolume;

    if(titleBGM) titleBGM.volume = realBGMVol;
    if(clearBGM) clearBGM.volume = realBGMVol;
    
    if(currentAudio && !fadeInterval) currentAudio.volume = (currentMusicState==='rage' ? 0.5 : 0.4) * realBGMVol * 2.5;
    
    if(greyBGM) {
        let greyVolFactor = 0.0;
        if (isGreyMode && gameState === 'game' && !gameCleared && !isGameOver) {
            let minDist = Infinity;
            goblins.forEach(g => {
                if (g.hp > 0) {
                    const d1 = Math.abs(g.x - player1.x) + Math.abs(g.y - player1.y);
                    const d2 = Math.abs(g.x - player2.x) + Math.abs(g.y - player2.y);
                    minDist = Math.min(minDist, d1, d2);
                }
            });
            const CLOSE_DIST = 3;
            const FAR_DIST = 14;
            if (minDist <= CLOSE_DIST) greyVolFactor = 1.0;
            else if (minDist >= FAR_DIST) greyVolFactor = 0.0;
            else {
                greyVolFactor = 1.0 - (minDist - CLOSE_DIST) / (FAR_DIST - CLOSE_DIST);
            }
        }
        greyBGM.volume = 0.4 * realBGMVol * 2.5 * greyVolFactor;
    }

    if (!isGameOver && !gameCleared && signalState.active && !signalState.agreedTime && performance.now() - signalState.startTime > 3000) {
        signalState.active = false;
        signalState.p1 = false;
        signalState.p2 = false;
        signalMsgEl.style.opacity = 0;
    }

    updateInputPosition(); 
    
    if (gameState === 'game') {
        if (!isDebugMode && (hpP1 <= 0 || hpP2 <= 0) && !isGameOver) {
            isGameOver = true;
            timerStopped = true;
            showResult();
        }

        if (!isDebugMode) { 
            if (isHost) {
                if (guestInputState.dx !== 0 || guestInputState.dy !== 0) {
                    movePlayer(player2, guestInputState.dx, guestInputState.dy);
                    guestInputState.dx = 0; guestInputState.dy = 0; 
                }
                
                if (guestInputState.attack) {
                    playerAttack(player2);
                    guestInputState.attack = false;
                }

                if (signalState.active && signalState.p1 && signalState.p2) {
                    if (!signalState.agreedTime) {
                        signalState.agreedTime = performance.now(); 
                    } else {
                        if (performance.now() - signalState.agreedTime > 2000) {
                            if (signalState.type === 'R') {
                                startDungeonGame(false); 
                            } else if (signalState.type === 'W') {
                                if (conn && conn.open) conn.send({ type: 'GO_TITLE' });
                                location.reload();
                            }
                        }
                    }
                }

                gameLoopStep(); 

                if (conn && conn.open) {
                    const now = performance.now();
                    if (now - lastSyncTime > SYNC_INTERVAL) {
                        const state = {
                            type: 'SYNC',
                            p1: { x: player1.x, y: player1.y, f: player1.facing, sc: player1.stepCount, dd: player1.deathDir },
                            p2: { x: player2.x, y: player2.y, f: player2.facing, sc: player2.stepCount, dd: player2.deathDir },
                            hp: { p1: hpP1, p2: hpP2 },
                            d: { x: daughter.x, y: daughter.y, r: daughter.rescued, er: daughter.rescuer },
                            g: goblins.map(g => ({
                                x: g.x, y: g.y, f: g.facing, s: g.state, hp: g.hp, 
                                sc: g.sizeScale, bo: g.bobOffset,
                                dt: g.deathTime, da: g.deathAngle, dp: g.dissolveProgress,
                                ic: g.isCasting
                            })),
                            sig: signalState, 
                            t: (!timerStopped) ? (performance.now()/1000 - startTime) : fixedTime,
                            cl: gameCleared,
                            go: isGameOver,
                            gm: isGreyMode,
                            hn: nameEl.value 
                        };
                        conn.send(state);
                        lastSyncTime = now;
                    }
                }
            }
        } else {
            gameLoopStep();
        }
    }

    draw(); 
    requestAnimationFrame(update);
} // --- update 終了 ---

function updateInputPosition() {
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / VIRTUAL_WIDTH;

    let nameSize = 34; let paddingTop = 32;
    if (nameEl.value.length > 25) { nameSize = 24; paddingTop = 15; }
    if (nameEl.value.length > 60) { nameSize = 18; paddingTop = 5; }
    nameEl.style.left = (162 * scale) + "px";
    nameEl.style.top = (160 * scale) + "px";
    nameEl.style.width = (700 * scale) + "px";
    nameEl.style.height = (100 * scale) + "px";
    nameEl.style.fontSize = (nameSize * scale) + "px";
    nameEl.style.paddingTop = (paddingTop * scale) + "px";
    
    if (gameState === 'matching' && isMatching) {
        nameEl.disabled = true;
        passEl.disabled = true;
    } else {
        nameEl.disabled = false;
        passEl.disabled = false;
    }

    nameEl.style.display = (gameState === 'matching') ? 'block' : 'none';

    passEl.style.left = (362 * scale) + "px";
    passEl.style.top = (312 * scale) + "px";
    passEl.style.width = (300 * scale) + "px";
    passEl.style.height = (56 * scale) + "px";
    passEl.style.fontSize = (35 * scale) + "px";
    passEl.style.display = (gameState === 'matching') ? 'block' : 'none';
    
    if (gameState === 'title') {
        controlsHelpEl.innerText = "クリック/Enter: 開始";
    } else if (gameState === 'matching') {
        if (isConnected) {
            controlsHelpEl.innerText = "クリック: 合流して開始！";
        } else if (isMatching) {
            controlsHelpEl.innerText = "待機中... クリック: キャンセル (合言葉変更)";
        } else {
            controlsHelpEl.innerText = "クリック: 待機開始 (ホスト判定)";
        }
    } else if (gameState === 'game') {
        if (isDebugMode) {
             controlsHelpEl.innerText = "【P1】移動:矢印 攻撃:Z 【P2】移動:WASD 攻撃:X | R:リスタート | [DEBUG MODE]";
        } else {
             if (isHost) {
                 controlsHelpEl.innerText = "【P1(あなた)】移動:矢印 攻撃:Z | 【P2(相棒)】操作待受中 | R:合図";
             } else {
                 controlsHelpEl.innerText = "【P2(あなた)】移動:矢印 攻撃:Z | 【P1(相棒)】操作待受中 | R:合図";
             }
        }
    }
} 

function draw() {
    ctx.clearRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
    if (gameState === 'game') {
        drawGameScreen();
    } else {
        if (titleBgImg.complete) ctx.drawImage(titleBgImg, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        else { ctx.fillStyle="#222"; ctx.fillRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT); }
        if (gameState === 'title') drawTitleScreen();
        else if (gameState === 'matching') drawMatchingScreen();
    }
    
    drawTriangleVolumeBar("BGM", UI_Y_START, bgmVolume, "#00ff00", isMutedBGM);
    drawTriangleVolumeBar("SE", UI_Y_START + 35, seVolume, "#00ff00", isMutedSE);
    drawTriangleVolumeBar("Light", UI_Y_START + 70, brightnessLevel, "#ffff00", false);
} 

function drawTriangleVolumeBar(label, y, volume, color, isMuted) {
    ctx.fillStyle = "white"; 
    ctx.font = "14px 'DotGothic16'"; 
    ctx.textAlign = "right";
    ctx.textBaseline = "middle"; 
    const textX = UI_X - 10;
    // 修正: 物理補正 -4px を適用
    const textY = y + BAR_H/2 - 4; 
    ctx.fillText(label, textX, textY);

    if (isMuted) {
        const textWidth = ctx.measureText(label).width;
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        // 修正: 斜線位置も補正後の座標に合わせる
        ctx.moveTo(textX - textWidth, textY + 6);
        ctx.lineTo(textX + 2, textY - 6);
        ctx.stroke();
    }

    ctx.beginPath();
    ctx.moveTo(UI_X, y + BAR_H); 
    ctx.lineTo(UI_X + BAR_W, y); 
    ctx.lineTo(UI_X + BAR_W, y + BAR_H);
    ctx.closePath();
    ctx.strokeStyle = "white"; 
    ctx.lineWidth = 1; 
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(UI_X, y + BAR_H);
    const curX = UI_X + (BAR_W * volume);
    const curY = y + BAR_H - (BAR_H * volume);
    ctx.lineTo(curX, curY); 
    ctx.lineTo(curX, y + BAR_H); 
    ctx.closePath();
    ctx.fillStyle = color; 
    ctx.fill();
} // --- drawTriangleVolumeBar 終了 ---

function drawTitleScreen() {
    ctx.textAlign = "center";
    ctx.fillStyle = "black"; ctx.font = "80px 'DotGothic16'";
    ctx.fillText("ゴブリンの巣穴", VIRTUAL_WIDTH / 2 + 4, VIRTUAL_HEIGHT / 2 + 4);
    ctx.fillStyle = "white"; ctx.fillText("ゴブリンの巣穴", VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT / 2);
    if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.font = "34px 'DotGothic16'";
        ctx.fillText("- PRESS TO START -", VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT / 2 + 100);
    }
} 

function drawMatchingScreen() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.85)"; ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
    ctx.fillStyle = "white"; ctx.textAlign = "center";
    
    ctx.textBaseline = "alphabetic";
    ctx.font = "28px 'DotGothic16'";
    ctx.fillText("名前", VIRTUAL_WIDTH / 2, 155); 
    ctx.fillText("合言葉", VIRTUAL_WIDTH / 2, 300); 
    
    ctx.strokeStyle = "white"; ctx.lineWidth = 2;
    ctx.strokeRect(VIRTUAL_WIDTH/2 - 350, 160, 700, 100);
    ctx.strokeRect(VIRTUAL_WIDTH/2 - 150, 305, 300, 60);

    ctx.textBaseline = "middle";
    const TEXT_OFFSET_Y = -4; 
    const BTN_CENTER_Y = 440 + 30; 
    const DEBUG_BTN_CENTER_Y = VIRTUAL_HEIGHT - 80 + 20; 

    if (isConnected) {
        ctx.fillStyle = "#ff0000"; 
        ctx.fillRect(VIRTUAL_WIDTH/2 - 80, 440, 160, 60);
        ctx.strokeStyle = "#ffaaaa"; ctx.lineWidth = 4;
        ctx.strokeRect(VIRTUAL_WIDTH/2 - 80, 440, 160, 60);
        
        ctx.fillStyle = "white";
        ctx.font = "30px 'DotGothic16'"; ctx.fillText("合流", VIRTUAL_WIDTH / 2, BTN_CENTER_Y + TEXT_OFFSET_Y);
    } else if (isMatching) {
        if (Math.floor(Date.now() / 400) % 2 === 0) {
            ctx.strokeStyle = "#ffff00"; ctx.lineWidth = 4;
            ctx.strokeRect(VIRTUAL_WIDTH/2 - 80, 440, 160, 60);
            ctx.fillStyle = "#ffff00";
            ctx.font = "30px 'DotGothic16'"; ctx.fillText("待機中", VIRTUAL_WIDTH / 2, BTN_CENTER_Y + TEXT_OFFSET_Y);
        } else {
            ctx.strokeStyle = "#555"; ctx.lineWidth = 4;
            ctx.strokeRect(VIRTUAL_WIDTH/2 - 80, 440, 160, 60);
            ctx.fillStyle = "#888";
            ctx.font = "30px 'DotGothic16'"; ctx.fillText("待機中", VIRTUAL_WIDTH / 2, BTN_CENTER_Y + TEXT_OFFSET_Y);
        }
        
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(VIRTUAL_WIDTH/2 - 350, 160, 700, 100);
        ctx.fillRect(VIRTUAL_WIDTH/2 - 150, 305, 300, 60);

    } else {
        ctx.strokeStyle = "white"; ctx.lineWidth = 4;
        ctx.strokeRect(VIRTUAL_WIDTH/2 - 80, 440, 160, 60);
        ctx.fillStyle = "white";
        ctx.font = "30px 'DotGothic16'"; ctx.fillText("待機", VIRTUAL_WIDTH / 2, BTN_CENTER_Y + TEXT_OFFSET_Y);
        
        ctx.lineWidth = 2;
        ctx.strokeRect(VIRTUAL_WIDTH - 150, VIRTUAL_HEIGHT - 80, 100, 40);
        ctx.font = "20px 'DotGothic16'"; ctx.fillText("予演", VIRTUAL_WIDTH - 100, DEBUG_BTN_CENTER_Y + TEXT_OFFSET_Y); 
    }
    ctx.textBaseline = "alphabetic";
} 

function initDecks(prefix) {
    const sKeyColor = prefix + 'color';
    const sKeyNormal = prefix + 'normal';
    const sKeyRage = prefix + 'rage';
    const sKeyIdx = prefix + 'idx';
    const sKeyCount = prefix + 'count';

    const storedColor = safeGetItem(sKeyColor);
    const storedNormal = safeGetItem(sKeyNormal);
    const storedRage = safeGetItem(sKeyRage);
    const storedIdx = safeGetItem(sKeyIdx);
    const storedCount = safeGetItem(sKeyCount);

    playCount = parseInt(storedCount || '0');

    if (storedColor && storedNormal && storedRage && storedIdx !== null) {
        try {
            deckColorIndices = JSON.parse(storedColor);
            deckNormalIndices = JSON.parse(storedNormal);
            deckRageIndices = JSON.parse(storedRage);
            currentDeckIndex = parseInt(storedIdx);
        } catch(e) {
            console.error("Session load error", e);
            generateNewDeck(prefix);
            return;
        }
        
        if (deckColorIndices.length !== 56 || deckNormalIndices.length !== 56 || deckRageIndices.length !== 56) {
             generateNewDeck(prefix);
        }
    } else {
        generateNewDeck(prefix);
    }
} 

function generateNewDeck(prefix) {
    deckColorIndices = Array.from({length: 56}, (_, i) => i);
    deckNormalIndices = Array.from({length: 56}, (_, i) => i);
    deckRageIndices = Array.from({length: 56}, (_, i) => i);
    shuffleArrayVisual(deckColorIndices);
    shuffleArrayVisual(deckNormalIndices);
    shuffleArrayVisual(deckRageIndices);
    currentDeckIndex = 0;
    saveSessionData(prefix);
}

function saveSessionData(prefix) {
    const sKeyColor = prefix + 'color';
    const sKeyNormal = prefix + 'normal';
    const sKeyRage = prefix + 'rage';
    const sKeyIdx = prefix + 'idx';
    const sKeyCount = prefix + 'count';

    safeSetItem(sKeyColor, JSON.stringify(deckColorIndices));
    safeSetItem(sKeyNormal, JSON.stringify(deckNormalIndices));
    safeSetItem(sKeyRage, JSON.stringify(deckRageIndices));
    safeSetItem(sKeyIdx, currentDeckIndex);
    safeSetItem(sKeyCount, playCount);
} 

function shuffleArrayVisual(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function stopCurrentBgm() {
    if (currentAudio) { 
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null; 
    }
    if (greyBGM && !greyBGM.paused) { 
        greyBGM.pause();
        greyBGM.currentTime = 0;
    }
    currentMusicState = 'normal';
}

function playAndFadeIn(srcOrAudio, targetVolRatio, fadeDuration = 600) {
    stopCurrentBgm(); 
    
    let audio;
    let srcName = "";
    if (typeof srcOrAudio === 'string') {
        audio = new Audio(srcOrAudio);
        srcName = srcOrAudio.split('/').pop(); 
    } else {
        audio = srcOrAudio;
        audio.currentTime = 0;
        srcName = "★ GREY MODE BGM ★";
    }
    audio.loop = true; 
    
    const realBGMVol = isMutedBGM ? 0 : bgmVolume;
    const targetVolume = targetVolRatio * realBGMVol * 2.5; 
    audio.volume = targetVolume;
    
    audio.play().catch((e) => { 
        console.log("BGM Play Error:", e); 
        if(isDebugMode) {
             currentBgmDebugName = "[Error] " + srcName;
             updateInfoText();
        }
    });
    
    if (typeof srcOrAudio === 'string') {
        currentAudio = audio;
    }
    
    if(isDebugMode) {
         currentBgmDebugName = "Playing: " + srcName;
         updateInfoText();
    }
} 

function playNormalBgm() { 
    if (isGreyMode) {
        playAndFadeIn(greyBGM, 0.4); 
        currentMusicState = 'grey';
    } else {
        if (currentStageBgm.normal) playAndFadeIn(currentStageBgm.normal, 0.4); 
        currentMusicState = 'normal'; 
    }
}

function enterRageBgm() { 
    if (isGreyMode) return; 
    if (currentMusicState === 'rage') return;
    if (currentStageBgm.rage) { playAndFadeIn(currentStageBgm.rage, 0.5); currentMusicState = 'rage'; }
}

function playSE(audioArrayOrSingle, volumeRatio = 0.6, pitchRand = 0.1, basePitch = 1.0) {
    if (isGreyMode) return; 
    if (isMutedSE) return;

    const audio = Array.isArray(audioArrayOrSingle) ? audioArrayOrSingle[Math.floor(rnd.nextFloat() * audioArrayOrSingle.length)] : audioArrayOrSingle;
    const clone = audio.cloneNode();
    clone.currentTime = 0;
    clone.volume = Math.min(1, volumeRatio * seVolume * 2); 
    clone.playbackRate = basePitch + (rnd.nextFloat() - 0.5) * pitchRand;
    clone.play().catch(() => {});
}

function playElectronicBlip() {
    if (isMutedSE) return;
    const actx = getSharedAudioContext(); 
    if (!actx) return;
    
    try {
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(actx.destination);
        const now = actx.currentTime;
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
        const vol = seVolume * 0.5; 
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.2);
    } catch(e) {
        console.warn("AudioContext limit reached");
    }
} // --- playElectronicBlip 終了 ---

function playSignalSound(type) {
    if (isMutedSE) return;
    const actx = getSharedAudioContext(); 
    if (!actx) return;
    
    try {
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.connect(gain);
        gain.connect(actx.destination);
        const now = actx.currentTime;
        const vol = seVolume * 0.4;
        let duration = 0;
        
        if (type === 'R') { 
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1500, now);
            osc.frequency.linearRampToValueAtTime(1400, now + 0.6);
            gain.gain.setValueAtTime(vol * 0.3, now); 
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            duration = 0.6;
        } else if (type === 'W') { 
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(100, now + 1.5);
            gain.gain.setValueAtTime(vol * 0.8, now);
            gain.gain.linearRampToValueAtTime(0, now + 1.5);
            duration = 1.5;
        }
        
        osc.start(now);
        osc.stop(now + duration);
    } catch(e) {
        console.warn("AudioContext limit reached");
    }
} // --- playSignalSound 終了 ---

function playClickSound() {
    if (isMutedSE) return;
    const actx = getSharedAudioContext(); 
    if (!actx) return;
    
    try {
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(actx.destination);
        const now = actx.currentTime;
        const vol = seVolume * 0.5;
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
    } catch(e) {
        console.warn("AudioContext limit reached");
    }
} // --- playClickSound 終了 ---

function playChurchBell() {
    if (isMutedSE) return;
    const actx = getSharedAudioContext(); 
    if (!actx) return;
    
    try {
        const now = actx.currentTime;
        const vol = seVolume * 0.8;
        const ratios = [1, 2, 3, 4.2, 5.4];
        const baseFreq = 300; 
        
        ratios.forEach((ratio, index) => {
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(baseFreq * ratio, now);
            const duration = 2.5 - (index * 0.4); 
            
            osc.connect(gain);
            gain.connect(actx.destination);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(vol / (index + 1), now + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            osc.start(now);
            osc.stop(now + duration);
        });
    } catch(e) {
        console.warn("AudioContext limit reached");
    }
} // --- playChurchBell 終了 ---

function calculateShortestPath() {
    let startNode = {x: startLeftX, y: startBottomY};
    let targetNode = {x: daughter.x, y: daughter.y};
    
    let queue = [{x: startNode.x, y: startNode.y, steps: 0}];
    let visited = Array.from({length: GRID_H}, () => Array(GRID_W).fill(false));
    visited[startNode.y][startNode.x] = true;

    while(queue.length > 0) {
        let curr = queue.shift();
        if (curr.x === targetNode.x && curr.y === targetNode.y) {
            return curr.steps;
        }
        for (let [dx, dy] of DIRS) {
            let nx = curr.x + dx, ny = curr.y + dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                if (grid[ny][nx] === 1 && !visited[ny][nx]) {
                    visited[ny][nx] = true;
                    queue.push({x: nx, y: ny, steps: curr.steps + 1});
                }
            }
        }
    }
    return distanceToDaughter * 1.5; 
} 

function startDungeonGame(debugFlag = isDebugMode, hostOverrideData = null) {
    isDebugMode = debugFlag; 
    
    const prefix = isDebugMode ? S_KEY_PREFIX_DEBUG : S_KEY_PREFIX_REAL;
    
    let seedVal;
    let selectedColorIdx;
    let selectedNormalIdx;
    let selectedRageIdx;

    if (hostOverrideData !== null) {
        seedVal = hostOverrideData.seed;
        selectedColorIdx = hostOverrideData.colorIdx;
        selectedNormalIdx = hostOverrideData.normalIdx;
        selectedRageIdx = hostOverrideData.rageIdx;
        playCount = hostOverrideData.playCount; 
        
    } else {
        initDecks(prefix);
        
        if (currentDeckIndex >= 56) {
             generateNewDeck(prefix);
        }

        seedVal = Math.floor(Math.random() * 4294967296) + Date.now();

        selectedColorIdx = deckColorIndices[currentDeckIndex];
        selectedNormalIdx = deckNormalIndices[currentDeckIndex];
        selectedRageIdx = deckRageIndices[currentDeckIndex];
        
        currentDeckIndex++;
        playCount++;
        saveSessionData(prefix); 
    }

    rnd = new Xorshift(seedVal);
    currentStageColor = FLOOR_COLORS_56[selectedColorIdx];
    currentStageBgm.normal = NORMAL_BGMS_56[selectedNormalIdx];
    currentStageBgm.rage = RAGE_BGMS_56[selectedRageIdx];
    
    debugCurrentNormalIdx = selectedNormalIdx;
    debugCurrentRageIdx = selectedRageIdx;

    isGreyMode = (playCount >= 2 && rnd.nextFloat() < 0.01); 

    if (isGreyMode) {
        canvas.classList.add('grey-mode-canvas');
    } else {
        canvas.classList.remove('grey-mode-canvas');
    }
    updateBrightnessFilter();
    
    gameState = 'game';
    titleBGM.pause();
    clearBGM.pause(); clearBGM.currentTime = 0;
    uiLayer.style.display = 'block';
    nameEl.style.display = 'none'; passEl.style.display = 'none';
    
    if (isDebugMode) {
        infoPanel.style.display = 'block';
        currentBgmDebugName = ""; 
    } else {
        infoPanel.style.display = 'none';
    }
    
    signalState = { active: false, type: null, startTime: 0, p1: false, p2: false, agreedTime: 0 };
    signalMsgEl.style.opacity = 0;

    if (!isDebugMode && isHost && conn && conn.open) {
        conn.send({ 
            type: 'START', 
            seed: seedVal, 
            colorIdx: selectedColorIdx, 
            normalIdx: selectedNormalIdx, 
            rageIdx: selectedRageIdx,
            playCount: playCount 
        });
    }

    generateDungeon();
} 

function updateInfoText() {
    if (!isDebugMode) return;
    infoPanel.innerText = `Deck(Debug): ${currentDeckIndex}/56\nColorIdx: ${deckColorIndices[currentDeckIndex-1]}\nNormalBGM: ${debugCurrentNormalIdx}\nRageBGM: ${debugCurrentRageIdx}\nPlayCount: ${playCount}\n${currentBgmDebugName}`;
}

function isPathValid() {
    let visited = Array.from({length: GRID_H}, () => Array(GRID_W).fill(false));
    let queue = [{x: startLeftX, y: startBottomY}];
    visited[startBottomY][startLeftX] = true;

    while(queue.length > 0) {
        let curr = queue.shift();
        if(curr.x === daughter.x && curr.y === daughter.y) return true;
        for(let [dx, dy] of DIRS) {
            let nx = curr.x + dx, ny = curr.y + dy;
            if(nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                if(grid[ny][nx] === 1 && !visited[ny][nx]) {
                    visited[ny][nx] = true;
                    queue.push({x: nx, y: ny});
                }
            }
        }
    }
    return false; 
} 

function addObstaclesToRooms() {
    for (const room of rooms) {
        if (room.w < 5 || room.h < 5) continue;
        const attempts = Math.floor((room.w * room.h) / 20) + 1; 
        
        for (let i = 0; i < attempts; i++) {
            const obW = Math.floor(rnd.nextFloat() * 3) + 2; 
            const obH = Math.floor(rnd.nextFloat() * 3) + 2; 
            const ox = room.x + 1 + Math.floor(rnd.nextFloat() * (room.w - obW - 1)); 
            const oy = room.y + 1 + Math.floor(rnd.nextFloat() * (room.h - obH - 1)); 

            let backup = [];
            for(let dy=0; dy<obH; dy++) {
                for(let dx=0; dx<obW; dx++) {
                    if (rnd.nextFloat() < 0.8) { 
                        const tx = ox + dx, ty = oy + dy;
                        if (grid[ty] && grid[ty][tx] === 1) {
                            backup.push({x: tx, y: ty});
                            grid[ty][tx] = 0;
                        }
                    }
                }
            }

            if (grid[daughter.y][daughter.x] === 0 || 
                grid[startBottomY][startLeftX] === 0 || 
                grid[startBottomY][startRightX] === 0) {
                backup.forEach(b => grid[b.y][b.x] = 1);
                continue;
            }

            if (!isPathValid()) {
                backup.forEach(b => grid[b.y][b.x] = 1);
            }
        }
    }
} 

function getNextStepBFS(startX, startY, targetX, targetY) {
    if(startX === targetX && startY === targetY) return null;
    let queue = [{x: startX, y: startY}];
    let cameFrom = new Map();
    cameFrom.set(`${startX},${startY}`, null);
    let found = false;
    
    let steps = 0;
    while(queue.length > 0 && steps < 200) {
        let curr = queue.shift();
        if (curr.x === targetX && curr.y === targetY) { found = true; break; }
        
        let dirs = [...DIRS].sort(() => rnd.nextFloat() - 0.5);
        for (let [dx, dy] of dirs) {
            let nx = curr.x + dx, ny = curr.y + dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx] === 1) {
                let key = `${nx},${ny}`;
                if (!cameFrom.has(key) && !isBlockedForGoblin(nx, ny)) {
                    cameFrom.set(key, {x: curr.x, y: curr.y});
                    queue.push({x: nx, y: ny});
                }
            }
        }
        steps++;
    }
    
    if (!found) return null;
    
    let curr = {x: targetX, y: targetY};
    let prev = cameFrom.get(`${curr.x},${curr.y}`);
    while(prev && (prev.x !== startX || prev.y !== startY)) {
        curr = prev;
        prev = cameFrom.get(`${curr.x},${curr.y}`);
    }
    return curr; 
} 

function applySmoothing() {
    for (let step = 0; step < 3; step++) {
        let tempGrid = grid.map(row => [...row]);
        for(let y = 1; y < GRID_H - 1; y++) {
            for(let x = 1; x < GRID_W - 1; x++) {
                if (y >= GRID_H - 10) continue;
                let floors = 0;
                for(let dy = -1; dy <= 1; dy++) {
                    for(let dx = -1; dx <= 1; dx++) {
                        if(dx === 0 && dy === 0) continue;
                        if(grid[y+dy][x+dx] === 1) floors++;
                    }
                }
                if (grid[y][x] === 0 && floors >= 5) tempGrid[y][x] = 1;
                else if (grid[y][x] === 1 && floors <= 3) tempGrid[y][x] = 0;
            }
        }
        let backup = grid.map(row => [...row]);
        grid = tempGrid;
        if (grid[daughter.y][daughter.x] === 0 || !isPathValid()) { grid = backup; break; }
    }
    
    let tempGrid2 = grid.map(row => [...row]);
    for(let y = 1; y < GRID_H - 1; y++) {
        for(let x = 1; x < GRID_W - 1; x++) {
            if (y >= GRID_H - 10) continue;
            if (grid[y][x] === 1) {
                let orthoFloors = 0;
                if(grid[y-1][x] === 1) orthoFloors++;
                if(grid[y+1][x] === 1) orthoFloors++;
                if(grid[y][x-1] === 1) orthoFloors++;
                if(grid[y][x+1] === 1) orthoFloors++;
                if(orthoFloors <= 1) tempGrid2[y][x] = 0;
            }
        }
    }
    let backup2 = grid.map(row => [...row]);
    grid = tempGrid2;
    if (grid[daughter.y][daughter.x] === 0 || !isPathValid()) { grid = backup2; }
} 

function placeBiscuitSafely() {
    healingBiscuit.active = false;
    let candidates = [
        {dx:0, dy:1}, 
        {dx:1, dy:0}, 
        {dx:-1, dy:0} 
    ];
    for (let c of candidates) {
        let bx = daughter.x + c.dx;
        let by = daughter.y + c.dy;
        if (by >= 0 && by < GRID_H && bx >= 0 && bx < GRID_W && grid[by][bx] === 1) {
            healingBiscuit = {x: bx, y: by, active: true};
            return;
        }
    }
} 

function generateDungeon() {
    grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
    floorVariant = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
    rooms = []; goblins = []; attackEffects = []; psychicArrays = []; floorDrawn = false;
    minimapFloorDrawn = false; foundDaughterNotified = false;
    p1LastHitTime = 0; p2LastHitTime = 0; 
    player1.hitShakeTime = 0; player2.hitShakeTime = 0;
    player1.stepCount = 0; player2.stepCount = 0;
    player1.deathDir = 0; player2.deathDir = 0;
    
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            floorVariant[y][x] = Math.floor(rnd.nextFloat()*7)+1; 
        }
    }

    const START_LENGTH = 6;
    startLeftX = Math.floor(GRID_W / 2) - 1; startRightX = startLeftX + 1;
    startBottomY = GRID_H - 1;
    const startEntryY = GRID_H - START_LENGTH;
    carveRect(startLeftX, startEntryY, 2, START_LENGTH);
    player1.x = startLeftX; player1.y = GRID_H - 1; player1.facing = 1;
    player2.x = startRightX; player2.y = GRID_H - 1; player2.facing = 1;

    const firstRoomW = Math.floor(rnd.nextFloat() * 10) + 8; 
    const firstRoomH = Math.floor(rnd.nextFloat() * 8) + 6; 
    const firstRoomX = Math.floor(GRID_W / 2 - firstRoomW / 2);
    const firstRoomY = Math.max(5, startEntryY - firstRoomH - 8 - Math.floor(rnd.nextFloat() * 15)); 
    carveRect(firstRoomX, firstRoomY, firstRoomW, firstRoomH);
    rooms.push({x: firstRoomX, y: firstRoomY, w: firstRoomW, h: firstRoomH});
    carveCorridor(startLeftX, startEntryY - 1, 0, startEntryY - firstRoomY + 5, 3);

    let branches = [{x: firstRoomX + Math.floor(firstRoomW / 2), y: firstRoomY, parentDir: 0}];
    let roomCount = 1;
    while (branches.length > 0 && roomCount < 20) {
        const i = Math.floor(rnd.nextFloat() * branches.length); 
        const branch = branches[i]; branches.splice(i, 1);
        let possibleDirs = [0,1,2,3].filter(d => d !== (branch.parentDir + 2) % 4).sort(() => rnd.nextFloat() - 0.5); 
        let added = 0;
        for (const dir of possibleDirs) {
            if (added >= 3) break; if (rnd.nextFloat() < 0.3) continue; 
            const length = Math.floor(rnd.nextFloat() * 15) + 8; 
            const endPos = carveCorridor(branch.x, branch.y, dir, length, Math.floor(rnd.nextFloat() * 4) + 2); 
            const newW = Math.floor(rnd.nextFloat() * 12) + 7; 
            const newH = Math.floor(rnd.nextFloat() * 10) + 5; 
            const [dx, dy] = DIRS[dir];
            let newX = endPos.x + dx - Math.floor(newW / 2);
            let newY = endPos.y + dy - Math.floor(newH / 2);
            newX = Math.max(3, Math.min(newX, GRID_W - newW - 3));
            newY = Math.max(3, Math.min(newY, GRID_H - newH - 6));
            if (newY + newH >= GRID_H - 5) continue;
            carveRect(newX, newY, newW, newH);
            rooms.push({x: newX, y: newY, w: newW, h: newH});
            const attachY = dir === 0 ? newY + newH - 1 : dir === 2 ? newY : newY + Math.floor(newH / 2);
            branches.push({x: newX + Math.floor(newW / 2), y: attachY, parentDir: dir});
            added++; roomCount++;
        }
    }

    placeDaughter();
    addObstaclesToRooms();
    applySmoothing();
    
    placeBiscuitSafely();

    placeGoblins();
    
    shortestPathSteps = calculateShortestPath();

    startTime = performance.now() / 1000;
    fixedTime = 0; timerStopped = false; foundDaughter = false; foundDaughterNotified = false; gameCleared = false; isGameOver = false;
    daughter.rescued = false; daughter.rescuer = null;
    hpP1 = 10; hpP2 = 10;
    document.getElementById('result-rank').style.display = 'none';
    document.getElementById('restart-hint').innerText = ""; 
    
    updateInfoText();
    playNormalBgm();
} 

function carveRect(x, y, w, h) {
    for (let dy = 0; dy < h; dy++) for (let dx = 0; dx < w; dx++) {
        const px = x + dx, py = y + dy;
        if (px >= 0 && px < GRID_W && py >= 0 && py < GRID_H) grid[py][px] = 1;
    }
}

function carveCorridor(startX, startY, dirIdx, length, width) {
    const [dx, dy] = DIRS[dirIdx];
    let x = startX, y = startY;
    for (let i = 0; i < length; i++) {
        const offset = Math.floor(width / 2);
        for (let w = -offset; w <= offset; w++) {
            const px = x + (dx === 0 ? w : 0), py = y + (dy === 0 ? w : 0);
            if (px >= 0 && px < GRID_W && py >= 0 && py < GRID_H) grid[py][px] = 1;
        }
        x += dx; y += dy;
    }
    return {x: x - dx, y: y - dy};
}

function placeDaughter() {
    const sortedRooms = [...rooms].sort((a, b) => a.y - b.y);
    let targetRoom = sortedRooms.length >= 3 ? sortedRooms[Math.floor(rnd.nextFloat() * 2)] : sortedRooms[0]; 
    let candidates = [];
    for (let dy = 0; dy < targetRoom.h; dy++) for (let dx = 0; dx < targetRoom.w; dx++) {
        const px = targetRoom.x + dx, py = targetRoom.y + dy;
        if (grid[py][px] === 1) candidates.push({x: px, y: py});
    }
    const pos = candidates[Math.floor(rnd.nextFloat() * candidates.length)] || {x: targetRoom.x+1, y: targetRoom.y+1}; 
    daughter.x = pos.x; daughter.y = pos.y;
    distanceToDaughter = (GRID_H - 1) - daughter.y;
}

function placeGoblins() {
    goblins = [];
    let validTiles = [];
    for (let y = 0; y < GRID_H; y++) for (let x = 0; x < GRID_W; x++) if (grid[y][x] === 1) validTiles.push({x, y});
    validTiles = validTiles.filter(pos => 
        pos.y < GRID_H - 10 && !(pos.x === daughter.x && pos.y === daughter.y)
    );
    
    let goblinCount = isGreyMode ? 7 : Math.max(5, Math.min(Math.floor(validTiles.length * 0.1), 40));
    
    for(let i=0; i<goblinCount; i++) {
        if(validTiles.length === 0) break;
        const idx = Math.floor(rnd.nextFloat() * validTiles.length); 
        const pos = validTiles[idx]; validTiles.splice(idx, 1);
        
        const isGiant = isGreyMode ? false : rnd.nextFloat() < 0.15; 
        const sizeScale = isGreyMode ? 1.0 : (isGiant ? 1.15 : (0.85 + rnd.nextFloat() * 0.25)); 
        const hp = isGreyMode ? 1 : (isGiant ? 4 : 3);

        goblins.push({
            x: pos.x, y: pos.y, hp: hp, maxHp: hp, facing: Math.floor(rnd.nextFloat() * 4), 
            state: STATE.IDLE, lastTurnTime: performance.now(), lastMoveTime: 0, lastAttackTime: 0,
            chargeStartTime: 0, reappearStartTime: 0,
            isCasting: false, castEndTime: 0, 
            rallyTarget: null, 
            moveCooldown: IDLE_COOLDOWN, targetPlayer: null, nextUpdate: 0,
            sizeScale: sizeScale, isGiant: isGiant,
            bobOffset: rnd.nextFloat() * 100, 
            deathTime: 0, deathDir: 0, deathAngle: 0, dissolveProgress: 0
        });
    }
} 

function gameLoopStep() {
    const now = performance.now();
    goblins = goblins.filter(g => {
        if (!g.nextUpdate || now >= g.nextUpdate) {
            if (isGreyMode) updateGrey(g, now);
            else updateGoblin(g, now);
            g.nextUpdate = now + GOBLIN_UPDATE_INTERVAL;
        }
        return !(g.state === STATE.DYING && g.dissolveProgress >= 1.0);
    });

    if (isGreyMode) {
        psychicArrays = psychicArrays.filter(a => {
            const t = now - a.startTime;
            if (t >= a.duration) {
                [player1, player2].forEach(p => {
                    if (Math.abs(p.x - a.x) <= 1 && Math.abs(p.y - a.y) <= 1) {
                        hpP1 = 0; hpP2 = 0; 
                        if (!isDebugMode && !isGameOver && !gameCleared) {
                            damagePlayer(p, 100); 
                        }
                    }
                });
                return false; 
            }
            return true; 
        });
    }
    
    if (now - lastMinimapUpdate > MINIMAP_UPDATE_INTERVAL) {
        updateMinimap();
        lastMinimapUpdate = now;
    }
} 

function isAdjacent(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1; }

function updateGoblin(g, now) {
    if (g.state === STATE.DYING) {
        const elapsed = now - g.deathTime;
        const FADE_START_DELAY = 1500; 
        const FADE_DURATION = 1000;        

        if (elapsed < 500) {
            g.deathAngle = (elapsed / 500) * (Math.PI / 2) * g.deathDir;
        } else {
            g.deathAngle = (Math.PI / 2) * g.deathDir;
        }

        if (elapsed >= FADE_START_DELAY) {
            g.dissolveProgress = Math.min(1.0, (elapsed - FADE_START_DELAY) / FADE_DURATION);
        } else {
            g.dissolveProgress = 0;
        }
        return; 
    }

    if (g.hp <= 0) return; 
    const canMove = now - g.lastMoveTime >= g.moveCooldown;

    if (g.state === STATE.RAGE) {
        g.targetPlayer = daughter.rescuer === 'p1' ? player1 : player2;
        moveGoblinToward(g, g.targetPlayer.x, g.targetPlayer.y);
        if (isAdjacent(g, g.targetPlayer)) tryGoblinAttack(g, g.targetPlayer, now);
        g.lastMoveTime = now; return;
    }
    if (g.state === STATE.LOCK) {
        if (isAdjacent(g, g.targetPlayer)) tryGoblinAttack(g, g.targetPlayer, now);
        else setGoblinState(g, STATE.ALERT, now);
        g.lastMoveTime = now; return;
    }
    
    let sensed = [];
    [player1, player2].forEach(p => {
        const dist = Math.hypot(g.x - p.x, g.y - p.y);
        const los = hasLineOfSight(g.x, g.y, p.x, p.y);
        if (dist <= SMELL_RADIUS || (dist <= SIGHT_RADIUS && los)) {
            sensed.push({p: p, d: dist});
        }
    });
    const sensedPlayer = sensed.length > 0 ? sensed.sort((a,b)=>a.d-b.d)[0].p : null;

    if (g.state === STATE.ALERT) {
        g.targetPlayer = g.targetPlayer || sensedPlayer; 
        if (!g.targetPlayer) { setGoblinState(g, STATE.IDLE, now); return; }
        if (isAdjacent(g, g.targetPlayer)) { setGoblinState(g, STATE.LOCK, now); return; }
        if (canMove) {
            preprocessGoblinMovement(g, g.targetPlayer);
            moveGoblinToward(g, g.targetPlayer.x, g.targetPlayer.y);
            g.lastMoveTime = now;
        }
    } else if (sensedPlayer) { 
        setGoblinState(g, STATE.ALERT, now); g.targetPlayer = sensedPlayer;
    } else if (g.state === STATE.IDLE && canMove) { 
        const dirs = DIRS.map((d, i) => ({d, i})).sort(() => rnd.nextFloat() - 0.5); 
        for (const {d: [dx, dy], i} of dirs) {
            const nx = g.x + dx, ny = g.y + dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx] === 1 && !isBlockedForGoblin(nx, ny)) {
                g.x = nx; g.y = ny; g.facing = i; g.lastMoveTime = now; break;
            }
        }
    }
    
    const isSearching = g.state === STATE.IDLE || g.state === STATE.ALERT;
    if (isSearching && !canMove) {
        let targetsInSight = [];
        let pList = [player1, player2];
        
        for(let p of pList) {
            if(hpP1 <= 0 && p === player1) continue;
            if(hpP2 <= 0 && p === player2) continue;

            const dx = p.x - g.x;
            const dy = p.y - g.y;
            let inCone = false;
            
            if (g.facing === 0) { 
                if (Math.abs(dx) <= 1 && dy >= -3 && dy < 0) inCone = true;
            } else if (g.facing === 1) { 
                if (dx >= 1 && dx <= 3 && Math.abs(dy) <= 1) inCone = true;
            } else if (g.facing === 2) { 
                if (Math.abs(dx) <= 1 && dy >= 1 && dy <= 3) inCone = true;
            } else if (g.facing === 3) { 
                if (dx >= -3 && dx <= -1 && Math.abs(dy) <= 1) inCone = true;
            }
            if (inCone) targetsInSight.push({p:p, d: Math.abs(dx)+Math.abs(dy)});
        }

        if (targetsInSight.length > 0) {
            g.lastTurnTime = now;
        } else if (now - g.lastTurnTime > GOBLIN_LOOK_INTERVAL) {
            g.facing = Math.floor(rnd.nextFloat() * 4); g.lastTurnTime = now; 
        }
    }
} 

function updateGrey(g, now) {
    if (g.state === STATE.DYING) {
        const elapsed = now - g.deathTime;
        const DISSOLVE_DURATION = 1000; 

        if (elapsed < DISSOLVE_DURATION) {
            g.dissolveProgress = elapsed / DISSOLVE_DURATION;
        } else {
            g.dissolveProgress = 1.0;
        }
        return;
    }

    if (g.hp <= 0) return;
    
    if (g.isCasting && now >= g.castEndTime) {
        g.isCasting = false;
        if (g.targetPlayer) {
            const distToTarget = Math.abs(g.x - g.targetPlayer.x) + Math.abs(g.y - g.targetPlayer.y);
            if (distToTarget <= 2 && g.state !== STATE.CHARGE && g.state !== STATE.REAPPEAR) {
                g.state = STATE.CHARGE;
                g.chargeStartTime = now;
                return;
            }
        }
    }

    let sensed = [];
    [player1, player2].forEach(p => {
        const dist = Math.hypot(g.x - p.x, g.y - p.y);
        if (dist <= 6) sensed.push({p: p, d: dist});
    });
    const sensedPlayer = sensed.length > 0 ? sensed.sort((a,b)=>a.d-b.d)[0].p : null;

    let nearestAlly = null;
    let minDistToAlly = Infinity;
    goblins.forEach(other => {
        if (other !== g && other.hp > 0) {
            const d = Math.abs(g.x - other.x) + Math.abs(g.y - other.y);
            if (d < minDistToAlly) { minDistToAlly = d; nearestAlly = other; }
        }
    });

    if (g.state === STATE.REAPPEAR) {
        if (now - g.reappearStartTime >= 1000) {
            g.state = STATE.ALERT;
            g.lastMoveTime = now;
            if (nearestAlly) {
                nearestAlly.rallyTarget = {x: g.x, y: g.y};
                g.rallyTarget = {x: nearestAlly.x, y: nearestAlly.y};
                if (nearestAlly.state === STATE.IDLE) nearestAlly.state = STATE.ALERT;
            }
        }
        return; 
    }

    if (g.state === STATE.CHARGE) {
        if (now - g.chargeStartTime >= 1000) {
            let validTiles = [];
            for(let y=Math.max(0, g.y-5); y<=Math.min(GRID_H-1, g.y+5); y++) {
                for(let x=Math.max(0, g.x-5); x<=Math.min(GRID_W-1, g.x+5); x++) {
                    if (grid[y][x] === 1 && !isBlockedForGoblin(x, y)) {
                        const dToPlayer = g.targetPlayer ? Math.abs(x - g.targetPlayer.x) + Math.abs(y - g.targetPlayer.y) : 3;
                        if (dToPlayer >= 2 && dToPlayer <= 5) validTiles.push({x, y});
                    }
                }
            }
            if (validTiles.length > 0) {
                if (nearestAlly) {
                    validTiles.sort((a, b) => {
                        let da = Math.abs(a.x - nearestAlly.x) + Math.abs(a.y - nearestAlly.y);
                        let db = Math.abs(b.x - nearestAlly.x) + Math.abs(b.y - nearestAlly.y);
                        return da - db;
                    });
                    const topTiles = validTiles.slice(0, Math.min(3, validTiles.length));
                    const t = topTiles[Math.floor(rnd.nextFloat() * topTiles.length)]; 
                    g.x = t.x; g.y = t.y;
                } else {
                    const t = validTiles[Math.floor(rnd.nextFloat() * validTiles.length)]; 
                    g.x = t.x; g.y = t.y;
                }
            }
            g.state = STATE.REAPPEAR;
            g.reappearStartTime = now;
        }
        return;
    }

    if (g.state === STATE.ALERT) {
        g.targetPlayer = g.targetPlayer || sensedPlayer;
        if (!g.targetPlayer) { g.state = STATE.IDLE; return; }

        const distToTarget = Math.abs(g.x - g.targetPlayer.x) + Math.abs(g.y - g.targetPlayer.y);
        
        if (distToTarget <= 2 && !g.isCasting && g.state !== STATE.CHARGE && g.state !== STATE.REAPPEAR) {
            g.state = STATE.CHARGE;
            g.chargeStartTime = now;
            return;
        }

        if (now - g.lastAttackTime > GREY_ARRAY_COOLDOWN && !g.isCasting) {
            let ally = goblins.find(other => other !== g && other.hp > 0 && other.state === STATE.ALERT && Math.hypot(g.x - other.x, g.y - other.y) <= 5 && !other.isCasting);
            if (ally) {
                psychicArrays.push({
                    x: g.targetPlayer.x, y: g.targetPlayer.y,
                    startTime: now, duration: 2000, targetPlayer: g.targetPlayer
                });
                g.lastAttackTime = now;
                ally.lastAttackTime = now;
                g.isCasting = true;
                g.castEndTime = now + 2000;
                ally.isCasting = true;
                ally.castEndTime = now + 2000;
            }
        }

        if (now - g.lastMoveTime >= g.moveCooldown) {
            let moved = false;
            
            if (g.rallyTarget) {
                const distToRally = Math.abs(g.x - g.rallyTarget.x) + Math.abs(g.y - g.rallyTarget.y);
                if (distToRally <= 1) {
                    g.rallyTarget = null; 
                } else {
                    let step = getNextStepBFS(g.x, g.y, g.rallyTarget.x, g.rallyTarget.y);
                    if (step) {
                        let safe = true;
                        if (g.targetPlayer) {
                            const dToP = Math.abs(step.x - g.targetPlayer.x) + Math.abs(step.y - g.targetPlayer.y);
                            if (dToP <= 1) safe = false;
                        }
                        if (safe) {
                            if (step.x > g.x) g.facing = 1; else if (step.x < g.x) g.facing = 3;
                            else if (step.y > g.y) g.facing = 2; else g.facing = 0;
                            g.x = step.x; g.y = step.y;
                            moved = true;
                        } else {
                            g.rallyTarget = null;
                        }
                    } else {
                        g.rallyTarget = null; 
                    }
                }
            }

            if (!moved) {
                let bestDir = -1, bestScore = -Infinity;
                DIRS.forEach(([dx, dy], i) => {
                    const nx = g.x + dx, ny = g.y + dy;
                    if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx]===1 && !isBlockedForGoblin(nx, ny)) {
                        const dToPlayer = Math.abs(nx - g.targetPlayer.x) + Math.abs(ny - g.targetPlayer.y);
                        let score = 0;
                        if (dToPlayer === 2) score = 20;
                        else if (dToPlayer === 3) score = 10;
                        else if (dToPlayer > 3) score = -dToPlayer * 2; 
                        else score = -100; 
                        
                        if (nearestAlly) {
                            const dToAlly = Math.abs(nx - nearestAlly.x) + Math.abs(ny - nearestAlly.y);
                            score -= dToAlly * 1.5; 
                        }
                        
                        if (score > bestScore) { bestScore = score; bestDir = i; }
                    }
                });
                if (bestDir !== -1) {
                    g.x += DIRS[bestDir][0]; g.y += DIRS[bestDir][1]; g.facing = bestDir;
                }
            }
            g.lastMoveTime = now;
        }
    } else if (sensedPlayer) {
        g.state = STATE.ALERT; g.targetPlayer = sensedPlayer;
        g.moveCooldown = CHASE_COOLDOWN;
        if (nearestAlly && nearestAlly.state === STATE.IDLE) {
            nearestAlly.state = STATE.ALERT;
            nearestAlly.targetPlayer = sensedPlayer;
        }
    } else if (g.state === STATE.IDLE && now - g.lastMoveTime >= g.moveCooldown) {
        let moved = false;
        if (g.rallyTarget) {
            const distToRally = Math.abs(g.x - g.rallyTarget.x) + Math.abs(g.y - g.rallyTarget.y);
            if (distToRally <= 1) {
                g.rallyTarget = null;
            } else {
                let step = getNextStepBFS(g.x, g.y, g.rallyTarget.x, g.rallyTarget.y);
                if (step) {
                    if (step.x > g.x) g.facing = 1; else if (step.x < g.x) g.facing = 3;
                    else if (step.y > g.y) g.facing = 2; else g.facing = 0;
                    g.x = step.x; g.y = step.y;
                    moved = true;
                } else {
                    g.rallyTarget = null;
                }
            }
        }
        
        if (!moved && nearestAlly) {
            const distToAlly = Math.abs(g.x - nearestAlly.x) + Math.abs(g.y - nearestAlly.y);
            if (distToAlly > 3) {
                let step = getNextStepBFS(g.x, g.y, nearestAlly.x, nearestAlly.y);
                if (step) {
                    if (step.x > g.x) g.facing = 1; else if (step.x < g.x) g.facing = 3;
                    else if (step.y > g.y) g.facing = 2; else g.facing = 0;
                    g.x = step.x; g.y = step.y;
                    moved = true;
                }
            }
        }
        
        if (!moved) {
            const dirs = DIRS.map((d, i) => ({d, i})).sort(() => rnd.nextFloat() - 0.5); 
            for (const {d: [dx, dy], i} of dirs) {
                const nx = g.x + dx, ny = g.y + dy;
                if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx] === 1 && !isBlockedForGoblin(nx, ny)) {
                    g.x = nx; g.y = ny; g.facing = i; break;
                }
            }
        }
        g.lastMoveTime = now;
    }
} 

function setGoblinState(g, newState, now) {
    if (g.state === newState) return;
    g.state = newState; g.lastMoveTime = now;
    if(newState === STATE.IDLE) g.moveCooldown = IDLE_COOLDOWN;
    else if(newState === STATE.ALERT) g.moveCooldown = CHASE_COOLDOWN;
    else if(newState === STATE.LOCK) g.moveCooldown = GOBLIN_ATTACK_INTERVAL;
    else if(newState === STATE.RAGE) g.moveCooldown = RAGE_COOLDOWN;
} 

function moveGoblinToward(g, tx, ty) {
    let bestDir = -1, bestDist = Infinity;
    DIRS.forEach(([dx, dy], i) => {
        const nx = g.x + dx, ny = g.y + dy;
        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx]===1 && !isBlockedForGoblin(nx, ny)) {
            const d = Math.hypot(nx - tx, ny - ty);
            if (d < bestDist) { bestDist = d; bestDir = i; }
        }
    });
    if (bestDir !== -1) {
        g.x += DIRS[bestDir][0]; g.y += DIRS[bestDir][1]; g.facing = bestDir;
    }
} 

function hasLineOfSight(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    if(steps===0) return true;
    for(let i=1; i<steps; i++) {
        const x = Math.floor(x1 + dx*i/steps + 0.5), y = Math.floor(y1 + dy*i/steps + 0.5);
        if(grid[y]?.[x]===0) return false;
    }
    return true;
} 

function isBlockedForGoblin(nx, ny) {
    if (goblins.some(g => g.hp>0 && g.x === nx && g.y === ny)) return true;
    if (player1.x === nx && player1.y === ny) return true;
    if (player2.x === nx && player2.y === ny) return true;
    return false;
} 

function isBlockedForPlayer(nx, ny) {
    if (goblins.some(g => g.hp>0 && g.x === nx && g.y === ny)) return true;
    return false;
} 

function preprocessGoblinMovement(g, tp) {
    if(!tp) return;
    const dx = tp.x - g.x, dy = tp.y - g.y;
    if (Math.abs(dx)===1 && Math.abs(dy)===1) { 
        const c1 = {x: g.x+dx, y: g.y}, c2 = {x: g.x, y: g.y+dy};
        const candidates = [c1, c2].filter(c => grid[c.y][c.x]===1 && !isBlockedForGoblin(c.x, c.y));
        if (candidates.length > 0) {
            const c = candidates[Math.floor(rnd.nextFloat()*candidates.length)]; 
            g.x = c.x; g.y = c.y; 
            if (c.x !== g.x) g.facing = (c.x > g.x ? 1 : 3);
            else g.facing = (c.y > g.y ? 2 : 0);
        }
    }
} 

function tryGoblinAttack(g, target, now) {
    if (now - g.lastAttackTime < GOBLIN_ATTACK_INTERVAL) return;
    g.lastAttackTime = now;
    
    if(target.x > g.x) g.facing = 1; else if(target.x < g.x) g.facing = 3;
    else if(target.y > g.y) g.facing = 2; else g.facing = 0;

    const pitch = g.isGiant ? 0.4 : 1.0;
    const vol = g.isGiant ? 0.7 * 1.2 : 0.7;
    playSE(SE.goblinAttack, vol, 0.15, pitch);

    damagePlayer(target, 1); 

    if (conn && conn.open) {
        conn.send({
            type: 'SPAWN_EFFECT',
            x: target.x + (target.x - g.x)*0.1, y: target.y + (target.y - g.y)*0.1,
            kind: 'goblin', dir: g.facing
        });
    }
    attackEffects.push({
        x: target.x + (target.x - g.x)*0.1, y: target.y + (target.y - g.y)*0.1,
        type: 'goblin', dir: g.facing, startTime: performance.now(), duration: 120, shakeX:0, shakeY:0
    });
} 

function damagePlayer(p, amount) {
    const now = performance.now();
    const lastHit = p === player1 ? p1LastHitTime : p2LastHitTime;
    if (now - lastHit < IFRAME_DURATION) return;
    
    if (p === player1) { hpP1 = Math.max(0, hpP1 - amount); p1LastHitTime = now; }
    else { hpP2 = Math.max(0, hpP2 - amount); p2LastHitTime = now; }
    
    p.hitShakeTime = now;
    playSE(p===player1 ? SE.playerHit1 : SE.playerHit2, 0.9, 0.05);

    if (conn && conn.open) {
        conn.send({
            type: 'PLAYER_HIT',
            target: p === player1 ? 'p1' : 'p2'
        });
    }

    if (hpP1 <= 0 || hpP2 <= 0) {
        if (!isDebugMode && !isGameOver && !gameCleared) {
            isGameOver = true; timerStopped = true;
            player1.deathDir = rnd.nextFloat() < 0.5 ? 1 : -1;
            player2.deathDir = rnd.nextFloat() < 0.5 ? 1 : -1;
            
            showResult();
        }
    }
} 

function movePlayer(p, dx, dy) {
    if (!isDebugMode && (isGameOver || gameCleared)) return;

    if (dx === 0 && dy === -1) p.facing = 0;
    if (dx === 1 && dy === 0) p.facing = 1;
    if (dx === 0 && dy === 1) p.facing = 2;
    if (dx === -1 && dy === 0) p.facing = 3;

    const nx = p.x + dx, ny = p.y + dy;
    const other = p === player1 ? player2 : player1;
    
    if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H && grid[ny][nx] === 1 && 
        !isBlockedForPlayer(nx, ny) && !(nx === other.x && ny === other.y)) {
        p.x = nx; p.y = ny;
        p.stepCount++; 

        if (healingBiscuit.active && nx === healingBiscuit.x && ny === healingBiscuit.y) {
            healingBiscuit.active = false;
            if (p === player1) hpP1 = 10; else hpP2 = 10;
            playElectronicBlip();
        }

        if (!foundDaughter && nx === daughter.x && ny === daughter.y) {
            foundDaughter = true; daughter.rescued = true; daughter.rescuer = p === player1 ? 'p1' : 'p2';
            fixedTime = performance.now() / 1000 - startTime; timerStopped = true;
            goblins.forEach(g => { if(g.hp>0 && !isGreyMode) setGoblinState(g, STATE.RAGE, performance.now()); });
            enterRageBgm(); updateInfoText();
        }
        if (daughter.rescued && daughter.rescuer === (p === player1 ? 'p1' : 'p2')) {
            daughter.x = p.x; daughter.y = p.y;
        }
        checkClear();
    }
} 

function playerAttack(p) {
    if (!isDebugMode && daughter.rescued && daughter.rescuer === (p === player1 ? 'p1' : 'p2')) return;
    if (!isDebugMode && (isGameOver || gameCleared)) return;

    const now = performance.now();
    const lastAtk = p === player1 ? lastAttackTimeP1 : lastAttackTimeP2;
    if (now/1000 - lastAtk < ATTACK_COOLDOWN) return;
    if (p === player1) lastAttackTimeP1 = now/1000; else lastAttackTimeP2 = now/1000;

    const [dx, dy] = DIRS[p.facing];
    const tx = p.x + dx, ty = p.y + dy;
    let hit = false;
    
    goblins.forEach(g => {
        if (g.hp > 0 && g.x === tx && g.y === ty) {
            if (isGreyMode && (g.state === STATE.CHARGE || g.state === STATE.REAPPEAR)) return;
            
            g.hp -= 3; hit = true;
            if (!isGreyMode) {
                const pitch = g.isGiant ? 0.4 : 1.0;
                const vol = g.isGiant ? 0.8 * 1.2 : 0.8;
                playSE(SE.goblinHit, vol, 0.1, pitch);
            }
            if (g.hp <= 0) { 
                g.state = STATE.DYING;
                g.targetPlayer = null;
                g.deathTime = now;
                g.deathDir = rnd.nextFloat() < 0.5 ? 1 : -1; 
            }
        }
    });
    const other = p === player1 ? player2 : player1;
    if ((p===player1?hpP2>0:hpP1>0) && other.x === tx && other.y === ty) { damagePlayer(other, 3); hit = true; }

    playSE(p===player1 ? SE.playerAttack1 : SE.playerAttack2, hit?0.8:0.5, 0.05);
    
    const ex = tx + 0.5 + (rnd.nextFloat()-0.5)*0.2;
    const ey = ty + 0.5 + (rnd.nextFloat()-0.5)*0.2;
    
    if (isHost && conn && conn.open) {
        conn.send({
            type: 'SPAWN_EFFECT',
            x: ex, y: ey,
            kind: 'player', owner: p===player1?'p1':'p2', dir: p.facing
        });
    }
    attackEffects.push({
        x: ex, y: ey,
        type: 'player', owner: p===player1?'p1':'p2', dir: p.facing, startTime: performance.now(), duration: 100
    });
} 

function checkClear() {
    const isP1Home = player1.y === startBottomY && (player1.x === startLeftX || player1.x === startRightX);
    const isP2Home = player2.y === startBottomY && (player2.x === startLeftX || player2.x === startRightX);
    
    if (foundDaughter && daughter.rescued && isP1Home && isP2Home && (!isGameOver || isDebugMode)) {
        gameCleared = true; stopCurrentBgm();
        if (!isGreyMode) {
            clearBGM.currentTime = 0;
            clearBGM.loop = true; 
            clearBGM.play().catch(()=>{});
        }
        showResult();
    }
} 

function showResult() {
    const rankEl = document.getElementById('result-rank');
    rankEl.style.display = 'block';
    
    const restartHint = document.getElementById('restart-hint');
    if (isDebugMode) {
         restartHint.innerHTML = "(R: 次のダンジョン)";
    } else {
        if (gameCleared) {
            restartHint.innerHTML = "(R: 続行 / W: 帰還)";
        } else {
            restartHint.innerHTML = "(R: 再起 / W: 撤退)";
        }
    }

    if ((hpP1 <= 0 || hpP2 <= 0) && !gameCleared) {
        document.getElementById('rank-grade').innerText = isGreyMode ? "Abducted" : "Game Over";
        document.getElementById('guild-comment').innerText = isGreyMode ? "生体サンプルの回収完了" : "死...";
        document.getElementById('rank-time').innerText = "";
        return;
    }

    const sBase = shortestPathSteps * 1.1; 
    const maxTime = (sBase * 2.8) + 1.0;
    
    const units = (fixedTime / maxTime) * 61;
    
    let rank = "C", comment = "ハラミブクロ";

    if (units <= 20) {
        rank = "S"; 
        comment = isGreyMode ? "未知との遭遇者" : "乙女の奇跡";
    } else if (units <= 40) {
        rank = "A"; 
        comment = isGreyMode ? "La Sonnambula" : "ふつうのむらむすめ";
    } else if (units <= 60) {
        rank = "B"; 
        comment = isGreyMode ? "アブダクティ" : "証聖者";
    } else {
        rank = "C"; 
        comment = isGreyMode ? "Starwomb maiden" : "ハラミブクロ";
    }
    
    document.getElementById('rank-grade').innerText = rank;
    document.getElementById('guild-comment').innerText = comment;
    document.getElementById('rank-time').innerText = `Time: ${fixedTime.toFixed(2)}s`;
} 

function drawGameScreen() {
    ctx.fillStyle = "#111"; ctx.fillRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT);
    
    const now = performance.now();
    
    let targetPlayer = player1;
    if (!isHost && !isDebugMode) {
        targetPlayer = player2; 
    }
    
    let vx = targetPlayer.x - VIEW_TILES_X/2;
    let vy = targetPlayer.y - VIEW_TILES_Y/2;
    vx = Math.max(0, Math.min(vx, GRID_W - VIEW_TILES_X));
    vy = Math.max(0, Math.min(vy, GRID_H - VIEW_TILES_Y));

    if(!floorDrawn) renderFloorCanvas();
    ctx.save();
    
    ctx.translate(GAME_OFFSET_X, GAME_OFFSET_Y);
    
    ctx.imageSmoothingEnabled = false;
    
    ctx.drawImage(floorCanvas, Math.floor(vx*SCALED_TILE), Math.floor(vy*SCALED_TILE), DARKNESS_WIDTH, DARKNESS_HEIGHT, 0, 0, DARKNESS_WIDTH, DARKNESS_HEIGHT);
    
    const drawSprite = (img, gx, gy, scaleX=1, scaleY=1, offsetY=0, filter='', rotation=0, originY=0) => {
        if (gx < vx || gx >= vx+VIEW_TILES_X || gy < vy || gy >= vy+VIEW_TILES_Y) return;
        const dx = (gx - vx) * SCALED_TILE;
        const dy = (gy - vy) * SCALED_TILE;
        const dw = SCALED_TILE * Math.abs(scaleX);
        const dh = SCALED_TILE * scaleY;
        const drawX = dx + (SCALED_TILE - dw)/2;
        const drawY = dy + SCALED_TILE - dh + offsetY;
        
        ctx.save();
        ctx.translate(Math.floor(drawX + dw/2), Math.floor(drawY + dh - originY));
        ctx.rotate(rotation);
        ctx.translate(-Math.floor(drawX + dw/2), -Math.floor(drawY + dh - originY));
        
        if(filter) ctx.filter = filter;
        if(scaleX < 0) {
             ctx.translate(Math.floor(drawX + dw), Math.floor(drawY)); ctx.scale(-1, 1); ctx.drawImage(img, 0, 0, dw, dh);
        } else {
             ctx.drawImage(img, Math.floor(drawX), Math.floor(drawY), dw, dh);
        }
        ctx.restore();
    };

    if (healingBiscuit.active) {
        drawSprite(biscuitImg, healingBiscuit.x, healingBiscuit.y, 0.2, 0.2, 0, "drop-shadow(0 0 4px #ffff00)");
    }

    if (isGreyMode && greyCircleImg.complete) {
        psychicArrays.forEach(a => {
            const t = now - a.startTime;
            if (t <= a.duration) {
                const ratio = t / a.duration; 
                const curSize = SCALED_TILE + (SCALED_TILE * 2 * ratio); 
                const dx = (a.x - vx) * SCALED_TILE + SCALED_TILE/2;
                const dy = (a.y - vy) * SCALED_TILE + SCALED_TILE/2;
                
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.translate(Math.floor(dx), Math.floor(dy));
                ctx.globalAlpha = 1.0 - (ratio * 0.3);
                ctx.drawImage(greyCircleImg, -curSize/2, -curSize/2, curSize, curSize);
                ctx.restore();
            }
        });
    }

    goblins.forEach(g => {
        if(g.hp <= 0 && g.state !== STATE.DYING) return; 
        
        if (isGreyMode) {
            let currentScale = g.sizeScale;
            
            if (g.state === STATE.DYING) {
                currentScale = g.sizeScale * (1.0 - g.dissolveProgress);
                const filterStr = `brightness(0)`; 
                const floatOffset = -(SCALED_TILE * g.sizeScale * 0.5 * g.dissolveProgress);
                drawSprite(greyImg, g.x, g.y, currentScale, currentScale, floatOffset, filterStr);
                return;
            }

            if (g.state === STATE.CHARGE) {
                const elapsed = now - g.chargeStartTime;
                const progress = Math.min(elapsed / 1000, 1.0);
                currentScale = Math.max(0.01, g.sizeScale * (1.0 - progress));
            } else if (g.state === STATE.REAPPEAR) {
                const elapsed = now - g.reappearStartTime;
                const progress = Math.min(elapsed / 1000, 1.0);
                currentScale = Math.max(0.01, g.sizeScale * progress);
            }
            
            let filterStr = '';
            if (g.isCasting) {
                const glow = Math.abs(Math.sin(now / 150)); 
                filterStr = `drop-shadow(0 0 ${10 * glow}px #ffff00) brightness(${1 + glow})`;
            }
            drawSprite(greyImg, g.x, g.y, currentScale, currentScale, 0, filterStr); 
        } else {
            const bob = Math.abs(Math.sin((now + g.bobOffset) / 150)) * 5; 
            let img = goblinImages.front;
            let scaleX = g.sizeScale; 
            if(g.facing === 0) img = goblinImages.back;
            else if(g.facing === 1) img = goblinImages.side; 
            else if(g.facing === 3) { img = goblinImages.side; scaleX *= -1; }
            
            let filter = g.isGiant ? 'sepia(0.5) hue-rotate(-30deg) brightness(0.9) contrast(0.8)' : '';
            
            let rotation = 0;
            
            if (g.state === STATE.DYING) {
                filter = 'brightness(0.6) sepia(0.4) saturate(0.3)';
                rotation = g.deathAngle;
                ctx.save();
                ctx.globalAlpha = 1.0 - g.dissolveProgress; 
            }

            drawSprite(img, g.x, g.y, scaleX, g.sizeScale, -bob, filter, rotation, 5);

            if (g.state === STATE.DYING) {
                ctx.restore(); 
            }
        }
    });

    if(!daughter.rescued) drawSprite(daughterImg, daughter.x, daughter.y);

    [player1, player2].forEach(p => {
        const isP2 = p === player2;
        const isDead = (hpP1 <= 0 || hpP2 <= 0) || isGameOver; 
        const shake = (now - p.hitShakeTime < HIT_SHAKE_DURATION) ? (rnd.nextFloat()*6-3) : 0; 
        
        let img = playerImages.front;
        let sx = 1;
        
        if (isDead && !isDebugMode) {
             let rot = (Math.PI / 2) * (p.deathDir || 1); 
             ctx.save();
             drawSprite(playerImages.side, p.x, p.y, 1, 1, 0, 'brightness(0)', rot, 5);
             ctx.restore();
        } 
        else {
            if (p.facing === 0) { 
                img = playerImages.back; if (p.stepCount % 2 !== 0) sx = -1;
            }
            else if (p.facing === 2) { 
                img = playerImages.front; if (p.stepCount % 2 !== 0) sx = -1;
            }
            else if (p.facing === 1) { 
                img = (p.stepCount % 2 === 0) ? playerImages.right1 : playerImages.right2; 
            }
            else if (p.facing === 3) { 
                img = (p.stepCount % 2 === 0) ? playerImages.right1 : playerImages.right2; sx = -1;
            }
            
            if (daughter.rescued && daughter.rescuer === (isP2?'p2':'p1') && !isDead) {
                drawSprite(daughterImg, p.x, p.y, 0.7, 0.7, -30 + shake);
            }
            
            const filterStr = isP2 ? 'hue-rotate(120deg)' : '';
            drawSprite(img, p.x, p.y, sx, 1, shake, filterStr);
        }

        if (p.x >= vx && p.x < vx+VIEW_TILES_X && p.y >= vy && p.y < vy+VIEW_TILES_Y) {
            let label = "";
            const isMe = (isHost || isDebugMode) ? (p === player1) : (p === player2);
            
            if (isMe) {
                label = nameEl.value;
            } else {
                if (isDebugMode) {
                    label = "相棒";
                } else {
                    label = otherPlayerName || "相棒";
                }
            }

            if (label && !isDead) { 
                ctx.save();
                const nameDx = (p.x - vx) * SCALED_TILE + SCALED_TILE/2;
                const nameDy = (p.y - vy) * SCALED_TILE - 15 + shake;
                ctx.textAlign = "center"; ctx.textBaseline = "bottom";
                
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                ctx.strokeStyle = "rgba(0, 0, 0, 0.7)"; ctx.lineWidth = 2;
                
                const maxWidth = SCALED_TILE * 3;
                const fontSize = 20;
                ctx.font = `${fontSize}px 'DotGothic16'`;
                const textWidth = ctx.measureText(label).width;
                
                let scaleFactor = 1;
                if (textWidth > maxWidth) {
                    scaleFactor = maxWidth / textWidth;
                }
                
                ctx.translate(Math.floor(nameDx), Math.floor(nameDy));
                ctx.scale(scaleFactor, 1);
                ctx.strokeText(label, 0, 0);
                ctx.fillText(label, 0, 0);
                
                ctx.restore();
            }
        }
    });

    darknessCtx.globalCompositeOperation = 'source-over';
    darknessCtx.fillStyle = '#000'; darknessCtx.fillRect(0,0,DARKNESS_WIDTH,DARKNESS_HEIGHT);
    
    const drawVision = (p) => {
        if(p.x>=vx && p.x<vx+VIEW_TILES_X && p.y>=vy && p.y<vy+VIEW_TILES_Y){
            const cx = (p.x-vx)*SCALED_TILE + SCALED_TILE/2;
            const cy = (p.y-vy)*SCALED_TILE + SCALED_TILE/2;
            
            darknessCtx.globalCompositeOperation = 'destination-out';
            darknessCtx.drawImage(visionHoleCanvas, Math.floor(cx - visionRadius), Math.floor(cy - visionRadius));

            if (isGreyMode) {
                darknessCtx.globalCompositeOperation = 'source-over';
                darknessCtx.drawImage(dreamyGlowCanvas, Math.floor(cx - visionRadius), Math.floor(cy - visionRadius));
                darknessCtx.globalCompositeOperation = 'destination-out'; 
            }
        }
    }; 
    
    drawVision(player1);
    drawVision(player2);
    ctx.drawImage(darknessCanvas, 0, 0);

    attackEffects = attackEffects.filter(e => now - e.startTime < e.duration);
    attackEffects.forEach(e => {
        if (e.x < vx || e.x >= vx+VIEW_TILES_X || e.y < vy || e.y >= vy+VIEW_TILES_Y) return;
        const t = (now - e.startTime) / e.duration;
        const sc = ATTACK_SCALE_START - t*(ATTACK_SCALE_START-1);
        const dx = (e.x - vx)*SCALED_TILE, dy = (e.y - vy)*SCALED_TILE;
        ctx.save(); 
        ctx.translate(Math.floor(dx), Math.floor(dy)); 
        ctx.scale(sc, sc);
        if(e.type==='goblin') ctx.drawImage(goblinAttackImg, -SCALED_TILE/2, -SCALED_TILE/2, SCALED_TILE, SCALED_TILE);
        else {
            if(e.owner==='p2') ctx.filter='invert(1)';
            ctx.drawImage(playerAttackImg, -SCALED_TILE/2, -SCALED_TILE/2, SCALED_TILE, SCALED_TILE); 
        }
        ctx.restore();
    });

    ctx.restore(); 

    drawAnalogClock();

    if (isDebugMode) {
        ctx.drawImage(minimapCanvas, VIRTUAL_WIDTH - 190, VIRTUAL_HEIGHT - 190);
    }
    drawHeartsUI();
    
    const effectiveGameOver = isGameOver || (hpP1 <= 0 || hpP2 <= 0);
    
    if (signalState.active) {
        let msg = "";
        
        if (gameCleared) {
            if (signalState.type === 'R') msg = "続行の合図だ！(R)";
            else if (signalState.type === 'W') msg = "帰還の合図だ！(W)";
        } else if (effectiveGameOver) {
            if (signalState.type === 'R') msg = "再起の合図だ！(R)";
            else if (signalState.type === 'W') msg = "帰還の合図だ！(W)";
        } else {
            if (signalState.type === 'R') msg = "撤退の合図だ！(R)";
        }
        
        if (msg) {
            signalMsgEl.innerText = msg;
            signalMsgEl.style.opacity = 1;
            
            if (signalState.p1 || signalState.p2) {
                 signalMsgEl.style.borderColor = "#0ff";
            }

            if (signalState.agreedTime) {
                signalMsgEl.style.color = "#ff0000";
                signalMsgEl.style.borderColor = "#ff0000";
            } else {
                signalMsgEl.style.color = "#ff0";
                signalMsgEl.style.borderColor = "rgba(255,255,255,0.5)";
            }
            
            if ((effectiveGameOver || gameCleared) && !signalState.agreedTime) {
                if ((isHost && signalState.p1) || (!isHost && signalState.p2)) {
                    signalMsgEl.innerText += "\n(待機中...)";
                } else if ((isHost && signalState.p2) || (!isHost && signalState.p1)) {
                    signalMsgEl.innerText += "\n(相手の提案)";
                }
            }
        } else {
            signalMsgEl.style.opacity = 0;
        }
    } else {
        signalMsgEl.style.opacity = 0;
    }
} 

function drawAnalogClock() {
    const CX = VIRTUAL_WIDTH - 60; 
    const CY = 176; 
    const R = 34;    

    const t = (!timerStopped) ? (performance.now()/1000 - startTime) : fixedTime;
    const sBase = shortestPathSteps * 1.1; 
    const maxTime = (sBase * 2.8) + 1.0; 

    const startAngle = -Math.PI / 2;
    const totalRad = Math.PI * 2;

    const sRatio = 20 / 61;
    const aRatio = 40 / 61;
    const bRatio = 60 / 61;
    
    const angleS = startAngle + totalRad * sRatio;
    const angleA = startAngle + totalRad * aRatio;
    const angleB = startAngle + totalRad * bRatio;
    const angleMax = startAngle + totalRad;

    ctx.save();
    ctx.translate(CX, CY);
    
    let gradS = ctx.createRadialGradient(0, 0, R*0.2, 0, 0, R);
    gradS.addColorStop(0, "#FFFACD"); gradS.addColorStop(0.5, "#FFD700"); gradS.addColorStop(1, "#DAA520");
    ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, R, startAngle, angleS); ctx.fillStyle = gradS; ctx.fill();

    let gradA = ctx.createRadialGradient(0, 0, R*0.2, 0, 0, R);
    gradA.addColorStop(0, "#FFFFFF"); gradA.addColorStop(0.5, "#C0C0C0"); gradA.addColorStop(1, "#A9A9A9");
    ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, R, angleS, angleA); ctx.fillStyle = gradA; ctx.fill();

    let gradB = ctx.createRadialGradient(0, 0, R*0.2, 0, 0, R);
    gradB.addColorStop(0, "#FFDAB9"); gradB.addColorStop(0.5, "#CD7F32"); gradB.addColorStop(1, "#8B4513");
    ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, R, angleA, angleB); ctx.fillStyle = gradB; ctx.fill();

    let gradC = ctx.createRadialGradient(0, 0, R*0.2, 0, 0, R);
    gradC.addColorStop(0, "#555555"); gradC.addColorStop(1, "#000000");
    ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, R, angleB, angleMax); ctx.fillStyle = gradC; ctx.fill();

    let gradFrame = ctx.createLinearGradient(-R, -R, R, R);
    gradFrame.addColorStop(0, "#E5E4E2"); gradFrame.addColorStop(0.5, "#A0A0A0"); gradFrame.addColorStop(1, "#F0F0F0");
    ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI*2);
    ctx.strokeStyle = gradFrame; ctx.lineWidth = 4; ctx.stroke();

    let currentRad;
    if (t >= maxTime) {
        const shake = (rnd.nextFloat() - 0.5) * 0.2; 
        currentRad = angleMax + shake;
    } else {
        currentRad = startAngle + (t / maxTime) * totalRad;
    }

    const tipX = Math.cos(currentRad) * (R - 4);
    const tipY = Math.sin(currentRad) * (R - 4);
    const tailX = Math.cos(currentRad + Math.PI) * 8; 
    const tailY = Math.sin(currentRad + Math.PI) * 8; 
    
    let gradNeedle = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
    gradNeedle.addColorStop(0, "#E5E4E2"); gradNeedle.addColorStop(1, "#FFFFFF");

    ctx.beginPath(); ctx.moveTo(tailX, tailY); ctx.lineTo(tipX, tipY);
    ctx.strokeStyle = gradNeedle; ctx.lineWidth = 3; ctx.stroke();
    
    ctx.beginPath(); ctx.arc(0, 0, 3.5, 0, Math.PI*2);
    ctx.fillStyle = gradFrame; ctx.fill();

    ctx.restore();
} 

function drawHeartsUI() {
    const heartSize = 30;
    const startX = 56; 
    const startY = 20;    
    const spacingX = 35;  
    const spacingY = 35;  
    
    ctx.save();
    ctx.font = `${heartSize}px 'DotGothic16'`;
    ctx.textBaseline = "top";
    
    let targetHp = hpP1;
    if (!isDebugMode && !isHost) {
        targetHp = hpP2;
    }
    
    for (let i = 0; i < 10; i++) {
        const row = Math.floor(i / 5); 
        const col = i % 5;                
        const x = startX + col * spacingX;
        const y = startY + row * spacingY;
        
        if (isGreyMode) {
            ctx.strokeStyle = "#002211"; 
            ctx.lineWidth = 4;
            if (i < targetHp) {
                ctx.fillStyle = "#00ffaa"; 
            } else {
                ctx.fillStyle = "#113322";
            }
        } else {
            ctx.strokeStyle = "#000000"; 
            ctx.lineWidth = 4;
            if (i < targetHp) {
                ctx.fillStyle = "#ff0000";
            } else {
                ctx.fillStyle = "#333333";
            }
        }
        ctx.strokeText("♥", x, y);
        ctx.fillText("♥", x, y);
    }
    ctx.restore();
} 

function renderFloorCanvas() {
    floorCanvas.width = GRID_W * SCALED_TILE; floorCanvas.height = GRID_H * SCALED_TILE;
    floorCtx.fillStyle = "#000"; floorCtx.fillRect(0,0,floorCanvas.width, floorCanvas.height);
    
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            let isFloor = grid[y][x] === 1;
            let isAdj = false;
            if (!isFloor) {
                for(let dy=-1; dy<=1; dy++) {
                    for(let dx=-1; dx<=1; dx++) {
                        if(grid[y+dy] && grid[y+dy][x+dx] === 1) isAdj = true;
                    }
                }
            }
            
            if (isFloor || isAdj) {
                const v = floorVariant[y][x];
                let rot=0, fx=1, fy=1;
                if(v===1) rot=Math.PI/2; if(v===2) rot=Math.PI; if(v===3) rot=Math.PI*1.5;
                if(v===4) fx=-1; if(v===5) fy=-1;
                
                floorCtx.save();
                floorCtx.translate(x*SCALED_TILE+SCALED_TILE/2, y*SCALED_TILE+SCALED_TILE/2);
                floorCtx.rotate(rot); floorCtx.scale(fx, fy);
                
                const targetImg = isGreyMode && greySpaceFloorImg.complete ? greySpaceFloorImg : floorTileImg;
                if(targetImg.complete) floorCtx.drawImage(targetImg, -SCALED_TILE/2, -SCALED_TILE/2, SCALED_TILE, SCALED_TILE);
                else { floorCtx.fillStyle="#555"; floorCtx.fillRect(-SCALED_TILE/2,-SCALED_TILE/2,SCALED_TILE,SCALED_TILE); }
                
                if (!isGreyMode) {
                    floorCtx.globalCompositeOperation = 'source-atop';
                    floorCtx.fillStyle = currentStageColor;
                    floorCtx.globalAlpha = 0.6; 
                    floorCtx.fillRect(-SCALED_TILE/2, -SCALED_TILE/2, SCALED_TILE, SCALED_TILE);
                    floorCtx.globalAlpha = 1.0; 
                }
                floorCtx.restore();
            }
        }
    }
    
    floorCtx.fillStyle = "#000";
    const r = SCALED_TILE * 0.35;
    
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            if (grid[y][x] === 0) {
                const top = y > 0 && grid[y-1][x] === 1;
                const bottom = y < GRID_H-1 && grid[y+1][x] === 1;
                const left = x > 0 && grid[y][x-1] === 1;
                const right = x < GRID_W-1 && grid[y][x+1] === 1;
                
                if (!top && !bottom && !left && !right) {
                    floorCtx.fillRect(x*SCALED_TILE, y*SCALED_TILE, SCALED_TILE, SCALED_TILE);
                    continue;
                }

                const tx = x * SCALED_TILE;
                const ty = y * SCALED_TILE;
                
                floorCtx.beginPath();
                if (top && left) { floorCtx.moveTo(tx, ty + r); floorCtx.arcTo(tx, ty, tx + r, ty, r); } 
                else { floorCtx.moveTo(tx, ty); }
                
                if (top && right) { floorCtx.lineTo(tx + SCALED_TILE - r, ty); floorCtx.arcTo(tx + SCALED_TILE, ty, tx + SCALED_TILE, ty + r, r); } 
                else { floorCtx.lineTo(tx + SCALED_TILE, ty); }
                
                if (bottom && right) { floorCtx.lineTo(tx + SCALED_TILE, ty + SCALED_TILE - r); floorCtx.arcTo(tx + SCALED_TILE, ty + SCALED_TILE, tx + SCALED_TILE - r, ty + SCALED_TILE, r); } 
                else { floorCtx.lineTo(tx + SCALED_TILE, ty + SCALED_TILE); }
                
                if (bottom && left) { floorCtx.lineTo(tx + r, ty + SCALED_TILE); floorCtx.arcTo(tx, ty + SCALED_TILE, tx, ty + SCALED_TILE - r, r); } 
                else { floorCtx.lineTo(tx, ty + SCALED_TILE); }
                
                floorCtx.closePath();
                floorCtx.fill();
            } 
            else if (grid[y][x] === 1) {
                const top = y > 0 && grid[y-1][x] === 1;
                const bottom = y < GRID_H-1 && grid[y+1][x] === 1;
                const left = x > 0 && grid[y][x-1] === 1;
                const right = x < GRID_W-1 && grid[y][x+1] === 1;
                
                const tx = x * SCALED_TILE;
                const ty = y * SCALED_TILE;
                
                if (!top && !left) {
                    floorCtx.beginPath(); floorCtx.moveTo(tx, ty); floorCtx.lineTo(tx + r, ty);
                    floorCtx.arc(tx + r, ty + r, r, Math.PI*1.5, Math.PI, true); floorCtx.fill();
                }
                if (!top && !right) {
                    floorCtx.beginPath(); floorCtx.moveTo(tx + SCALED_TILE, ty); floorCtx.lineTo(tx + SCALED_TILE - r, ty);
                    floorCtx.arc(tx + SCALED_TILE - r, ty + r, r, Math.PI*1.5, Math.PI*2); floorCtx.fill();
                }
                if (!bottom && !left) {
                    floorCtx.beginPath(); floorCtx.moveTo(tx, ty + SCALED_TILE); floorCtx.lineTo(tx + r, ty + SCALED_TILE);
                    floorCtx.arc(tx + r, ty + SCALED_TILE - r, r, Math.PI*0.5, Math.PI); floorCtx.fill();
                }
                if (!bottom && !right) {
                    floorCtx.beginPath(); floorCtx.moveTo(tx + SCALED_TILE, ty + SCALED_TILE); floorCtx.lineTo(tx + SCALED_TILE - r, ty + SCALED_TILE);
                    floorCtx.arc(tx + SCALED_TILE - r, ty + SCALED_TILE - r, r, Math.PI*0.5, 0, true); floorCtx.fill();
                }
            }
        }
    }
    
    const gradYStart = GRID_H * SCALED_TILE; 
    const gradYEnd = (GRID_H - 3) * SCALED_TILE; 
    
    const grad = floorCtx.createLinearGradient(0, gradYStart, 0, gradYEnd);
    grad.addColorStop(0, isGreyMode ? "rgba(0, 255, 100, 0.8)" : "rgba(255, 255, 200, 0.8)"); 
    grad.addColorStop(1, isGreyMode ? "rgba(0, 255, 100, 0)" : "rgba(255, 255, 200, 0)");        
    
    floorCtx.fillStyle = grad;
    floorCtx.fillRect(startLeftX*SCALED_TILE, gradYEnd, SCALED_TILE*2, SCALED_TILE*3);
    
    floorDrawn = true;
} 

function updateMinimap() {
    const size = 180;
    if (minimapCanvas.width !== size) minimapCanvas.width = minimapCanvas.height = size;
    if (!minimapFloorDrawn) {
        minimapFloorCanvas.width = minimapFloorCanvas.height = size;
        const scale = size / Math.max(GRID_W, GRID_H);
        minimapFloorCtx.fillStyle = "#444";
        for(let y=0; y<GRID_H; y++) for(let x=0; x<GRID_W; x++) if(grid[y][x]===1) minimapFloorCtx.fillRect(x*scale, y*scale, 1, 1);
        minimapFloorDrawn = true;
    }
    minimapCtx.fillStyle = "#111"; minimapCtx.fillRect(0,0,size,size);
    minimapCtx.drawImage(minimapFloorCanvas, 0, 0);
    const scale = size / Math.max(GRID_W, GRID_H);
    
    const drawDot = (x,y,c,s=3) => { minimapCtx.fillStyle=c; minimapCtx.fillRect(x*scale-s/2, y*scale-s/2, s, s); };
    
    drawDot(player1.x, player1.y, "#0ff", 5); 
    drawDot(player2.x, player2.y, "#f90", 5); 
    
    if(!daughter.rescued) drawDot(daughter.x, daughter.y, "#ff0");
    goblins.forEach(g => { if(g.hp>0) drawDot(g.x, g.y, g.state===STATE.RAGE?"#a0f":"#fa0"); });
} 

function handleDown(e) {
    if (gameState === 'gate') return;

    const pos = getMousePos(e);
    
    const volAreaX = UI_X - 60; 
    
    if (pos.x >= volAreaX && pos.x <= UI_X + BAR_W + 10) {
        if (pos.x < UI_X && pos.y >= UI_Y_START && pos.y <= UI_Y_START + BAR_H) {
            isMutedBGM = !isMutedBGM;
            safeSetItem('goblinsNest_muteBGM', isMutedBGM);
            return;
        }
        if (pos.y >= UI_Y_START - 5 && pos.y <= UI_Y_START + BAR_H + 5) {
            isDraggingBGM = true;
        }
    }
    
    if (pos.x >= volAreaX && pos.x <= UI_X + BAR_W + 10) {
        if (pos.x < UI_X && pos.y >= UI_Y_START + 35 && pos.y <= UI_Y_START + 35 + BAR_H) {
            isMutedSE = !isMutedSE;
            safeSetItem('goblinsNest_muteSE', isMutedSE);
            return;
        }
        if (pos.y >= UI_Y_START + 30 && pos.y <= UI_Y_START + 30 + BAR_H + 5) {
            isDraggingSE = true;
        }
    }

    if (pos.x >= volAreaX && pos.x <= UI_X + BAR_W + 10) {
        if (pos.y >= UI_Y_START + 65 && pos.y <= UI_Y_START + 65 + BAR_H + 5) {
            isDraggingBright = true;
        }
    }

    if (gameState === 'title') { 
        if (isInputLocked) return;
        
        if(pos.x > 300 && pos.x < 700 && pos.y > 200 && pos.y < 450) { 
            gameState='matching'; 
            titleBGM.play().catch(()=>{}); 
        }
    }
    else if (gameState === 'matching') {
        if (pos.x > VIRTUAL_WIDTH/2 - 80 && pos.x < VIRTUAL_WIDTH/2 + 80 && pos.y > 440 && pos.y < 500) {
            
            if (isConnected) {
                if (isHost) {
                    playChurchBell(); 
                    startDungeonGame(false); 
                } else {
                }
            } else if (isMatching) {
                isMatching = false;
                nameEl.disabled = false;
                passEl.disabled = false;
                if (peer) { peer.destroy(); peer = null; }
            } else {
                if(nameEl.value && passEl.value) {
                    playClickSound(); 
                    safeSetItem('goblinsNest_name', nameEl.value);
                    safeSetItem('goblinsNest_pass', passEl.value);
                    initPeer(passEl.value);
                }
            }
            if (document.activeElement === nameEl || document.activeElement === passEl) {
                nameEl.blur(); passEl.blur();
            }
        }
        if (!isMatching && !isConnected && pos.x > VIRTUAL_WIDTH - 150 && pos.x < VIRTUAL_WIDTH - 50 && pos.y > VIRTUAL_HEIGHT - 80) {
            startDungeonGame(true); 
        }
    }
} 

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: ((e.clientX || e.touches[0].clientX) - rect.left) * scaleX,
        y: ((e.clientY || e.touches[0].clientY) - rect.top) * scaleY
    };
}

const saveVolume = () => {
    if (isDraggingBGM || isDraggingSE || isDraggingBright) {
        safeSetItem('goblinsNest_bgmVol', bgmVolume);
        safeSetItem('goblinsNest_seVol', seVolume);
        safeSetItem('goblinsNest_bright', brightnessLevel);
    }
    isDraggingBGM = isDraggingSE = isDraggingBright = false;
}; 

canvas.addEventListener('mousedown', handleDown);
window.addEventListener('mousemove', (e) => {
    if (!isDraggingBGM && !isDraggingSE && !isDraggingBright) return;
    const pos = getMousePos(e);
    let vol = Math.max(0, Math.min(1, (pos.x - UI_X) / BAR_W));
    
    if (isDraggingBGM) bgmVolume = vol;
    if (isDraggingSE) seVolume = vol;
    if (isDraggingBright) {
        brightnessLevel = vol;
        updateBrightnessFilter();
    }
});
window.addEventListener('mouseup', saveVolume);
canvas.addEventListener('touchstart', (e) => { if(gameState!=='game') { e.preventDefault(); handleDown(e); } }, {passive:false});
window.addEventListener('touchend', saveVolume);

nameEl.addEventListener('input', () => {
    safeSetItem('goblinsNest_name', nameEl.value);
});
passEl.addEventListener('input', () => {
    passEl.value = passEl.value.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/[^a-zA-Z0-9]/g, '');
    safeSetItem('goblinsNest_pass', passEl.value);
});

const keys = {};
window.addEventListener('keydown', (e) => {
    if (e.isComposing || e.keyCode === 229) return;
    
    keys[e.key] = true;
    if (gameState === 'game') {
        const effectiveGameOver = isGameOver || (hpP1 <= 0 || hpP2 <= 0);

        if (e.key === 'r' || e.key === 'R') {
            if (!isDebugMode) {
                if (effectiveGameOver || gameCleared) {
                    signalState.active = true;
                    signalState.type = 'R';
                    
                    if (isHost) signalState.p1 = !signalState.p1;
                    else signalState.p2 = !signalState.p2;
                    
                    if (conn && conn.open) conn.send({ type: 'SIGNAL', key: 'R' });
                    playSignalSound('R');
                } else if (!signalState.active) {
                    signalState.active = true;
                    signalState.type = 'R';
                    signalState.startTime = performance.now();
                    if (isHost) signalState.p1 = true;
                    else signalState.p2 = true;
                    if (conn && conn.open) conn.send({ type: 'SIGNAL', key: 'R' });
                    playSignalSound('R');
                }
            } else {
                startDungeonGame(true);
            }
        }
        if (e.key === 'w' || e.key === 'W') {
             if (!isDebugMode) {
                if (effectiveGameOver || gameCleared) {
                    signalState.active = true;
                    signalState.type = 'W';
                    
                    if (isHost) signalState.p1 = !signalState.p1;
                    else signalState.p2 = !signalState.p2;
                    
                    if (conn && conn.open) conn.send({ type: 'SIGNAL', key: 'W' });
                    playSignalSound('W');
                } else if (!signalState.active) {
                    signalState.active = true;
                    signalState.type = 'W';
                    signalState.startTime = performance.now();
                    if (isHost) signalState.p1 = true;
                    else signalState.p2 = true;
                    if (conn && conn.open) conn.send({ type: 'SIGNAL', key: 'W' });
                    playSignalSound('W');
                }
            }
        }

        if (isHost || isDebugMode) {
            if (!isDebugMode && (effectiveGameOver || gameCleared)) return; 

            let dx = 0, dy = 0;
            if (keys['ArrowUp']) dy = -1;
            else if (keys['ArrowDown']) dy = 1;
            else if (keys['ArrowLeft']) dx = -1;
            else if (keys['ArrowRight']) dx = 1;
            
            if (dx !== 0 || dy !== 0) movePlayer(player1, dx, dy);
            if (keys['z'] || keys['Z']) playerAttack(player1);

            if (isDebugMode) {
                let d2x = 0, d2y = 0;
                if (keys['w'] || keys['W']) d2y = -1;
                else if (keys['s'] || keys['S']) d2y = 1;
                else if (keys['a'] || keys['A']) d2x = -1;
                else if (keys['d'] || keys['D']) d2x = 1;
                if (d2x !== 0 || d2y !== 0) movePlayer(player2, d2x, d2y);
                if (keys['x'] || keys['X']) playerAttack(player2);
            }
        } else {
            if (effectiveGameOver || gameCleared) return; 

            let dx = 0, dy = 0;
            if (keys['ArrowUp']) dy = -1;
            else if (keys['ArrowDown']) dy = 1;
            else if (keys['ArrowLeft']) dx = -1;
            else if (keys['ArrowRight']) dx = 1;

            if (dx !== 0 || dy !== 0) {
                if (conn && conn.open) conn.send({ type: 'MOVE', dx: dx, dy: dy });
            }
            if (keys['z'] || keys['Z']) {
                if (conn && conn.open) conn.send({ type: 'ATTACK' });
            }
        }
    } else if (gameState === 'title') {
        if(e.key === 'Enter') {
             if (isInputLocked) return;
             
             gameState='matching'; 
             titleBGM.play().catch(()=>{});
        }
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

// 修正: フォーカスが外れたら全キー入力をオフにする
window.addEventListener('blur', () => {
    for (let k in keys) {
        keys[k] = false;
    }
});

function initPeer(password) {
    if (peer) return;
    isMatching = true;
    
    const myId = PEER_ID_PREFIX + hashCode(password); 
    
    peer = new Peer(null, { debug: 1 }); 

    peer.on('open', (id) => {
        tryConnectAsHost(myId);
    });

    peer.on('error', (err) => {
        console.log("Peer Error: ", err);
        if (err.type === 'unavailable-id') {
            connectAsGuest(myId);
        } else {
            isMatching = false;
            alert("通信エラーが発生しました。合言葉を変えて試してください。");
        }
    });
}

function tryConnectAsHost(baseId) {
    const hostId = baseId + "_HOST";
    if(peer) peer.destroy();
    
    peer = new Peer(hostId, { debug: 1 });
    
    peer.on('open', (id) => {
        isHost = true;
        peer.on('connection', (c) => {
            if (conn) { c.close(); return; } 
            conn = c;
            setupConnection();
        });
    });
    
    peer.on('error', (err) => {
        if (err.type === 'unavailable-id') {
            connectAsGuest(baseId);
        }
    });
}

function connectAsGuest(baseId) {
    const hostId = baseId + "_HOST";
    if(peer) peer.destroy();
    peer = new Peer(null, {debug: 1});
    
    peer.on('open', () => {
        isHost = false;
        conn = peer.connect(hostId);
        if(!conn) { alert("ホストが見つかりません"); isMatching=false; return; }
        setupConnection();
    });
}

function setupConnection() {
    conn.on('open', () => {
        isConnected = true;
        isMatching = false; 
        if (!isHost) {
            conn.send({ type: 'NAME', name: nameEl.value });
        }
    });
    
    conn.on('data', (data) => {
        if (isHost) {
            if (data.type === 'MOVE') {
                guestInputState.dx = data.dx;
                guestInputState.dy = data.dy;
            } else if (data.type === 'ATTACK') {
                guestInputState.attack = true;
            } else if (data.type === 'SIGNAL') {
                if (isGameOver || gameCleared) {
                    signalState.active = true;
                    signalState.type = data.key;
                    signalState.p2 = !signalState.p2; 
                } else {
                    signalState.active = true;
                    signalState.type = data.key;
                    if (!signalState.startTime) signalState.startTime = performance.now();
                    signalState.p2 = true; 
                }
                playSignalSound(data.key);
            }
            else if (data.type === 'NAME') {
                otherPlayerName = data.name;
            }
        } else {
            if (data.type === 'SYNC') {
                player1.x = data.p1.x; player1.y = data.p1.y; player1.facing = data.p1.f; player1.stepCount = data.p1.sc;
                player2.x = data.p2.x; player2.y = data.p2.y; player2.facing = data.p2.f; player2.stepCount = data.p2.sc;
                hpP1 = data.hp.p1; hpP2 = data.hp.p2;
                daughter.x = data.d.x; daughter.y = data.d.y; daughter.rescued = data.d.r; daughter.rescuer = data.d.er;
                
                if (data.p1.dd) player1.deathDir = data.p1.dd;
                if (data.p2.dd) player2.deathDir = data.p2.dd;

                if (goblins.length !== data.g.length) goblins = new Array(data.g.length).fill({});
                data.g.forEach((gData, i) => {
                      goblins[i] = {
                          x: gData.x, y: gData.y, facing: gData.f, state: gData.s, hp: gData.hp,
                          sizeScale: gData.sc, bobOffset: gData.bo, 
                          deathTime: gData.dt, deathAngle: gData.da, dissolveProgress: gData.dp,
                          isCasting: gData.ic
                      };
                });
                
                signalState = data.sig;
                fixedTime = data.t;
                gameCleared = data.cl;
                isGameOver = data.go;
                isGreyMode = data.gm;
                
                otherPlayerName = data.hn;

                updateInputPosition();

            } else if (data.type === 'START') {
                startDungeonGame(false, { 
                    seed: data.seed, 
                    colorIdx: data.colorIdx, 
                    normalIdx: data.normalIdx, 
                    rageIdx: data.rageIdx,
                    playCount: data.playCount 
                });
                
            } else if (data.type === 'SPAWN_EFFECT') {
                if (data.kind === 'goblin') {
                      attackEffects.push({
                          x: data.x, y: data.y, type: 'goblin', dir: data.dir, startTime: performance.now(), duration: 120
                      });
                      const pitch = isGreyMode ? 1.0 : (Math.random() > 0.8 ? 0.4 : 1.0); 
                      playSE(SE.goblinAttack, 0.7, 0.15, pitch);
                } else if (data.kind === 'player') {
                      attackEffects.push({
                          x: data.x, y: data.y, type: 'player', owner: data.owner, dir: data.dir, startTime: performance.now(), duration: 100
                      });
                      playSE(data.owner==='p1'?SE.playerAttack1:SE.playerAttack2, 0.5, 0.05);
                }
            } else if (data.type === 'PLAYER_HIT') {
                const p = data.target === 'p1' ? player1 : player2;
                p.hitShakeTime = performance.now();
                playSE(data.target==='p1'?SE.playerHit1:SE.playerHit2, 0.9, 0.05);
            } else if (data.type === 'GO_TITLE') {
                location.reload();
            }
        }
    });

    conn.on('close', () => {
        alert("相手との接続が切れました");
        location.reload();
    });
}

update();
</script>
</body>
</html>